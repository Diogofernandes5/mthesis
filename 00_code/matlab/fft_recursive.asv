function y_io = fft_recursive(y_io, N, stages)
    % Recursive FFT function
    if N > 1
        half_N = N / 2;
        fractional_part = 5;

        stages = floor(stages/2);
        
        % Allocate memory for even and odd indexed elements
        ve = zeros(1, half_N);   % Even indexed
        vo = zeros(1, half_N);   % Odd indexed

        % Divide the input into even and odd parts
        ve = y_io(1:2:N);   % Even-indexed elements
        vo = y_io(2:2:N);   % Odd-indexed elements

        % Recursive calls for FFT on the two halves
        ve = fft_recursive(ve, half_N, stages);
        vo = fft_recursive(vo, half_N, stages);

        % Twiddle factor and combine
        for m = 1:half_N
            angle = -2 * pi * (m-1) / N;
            w = complex(round(cos(angle)), round(sin(angle)));  % Complex twiddle factor
            % w = complex(cos(angle), sin(angle));  % Complex twiddle factor
            w = round(w * 2.^fractional_part);

            [fft_ve, fft_vo] = bf_operation_recursive(N, ve(m), vo(m), w);
            
            y_io(m) = fft_ve;                    % X0 = ve + w * vo
            y_io(m + half_N) = fft_vo * 2.^-fractional_part;           % X1 = ve - w * vo
        end
    end
end