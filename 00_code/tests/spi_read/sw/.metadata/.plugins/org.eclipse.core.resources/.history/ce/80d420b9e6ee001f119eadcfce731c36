#include "xil_io.h"        // For Xil_In functions
#include "xparameters.h"   // XPAR parameters
#include "xil_printf.h"    // For printing
#include "xintc.h"         // For AXI Interrupt Controller
#include "xil_exception.h"

#define __DEBUG
//#define INTR_EN

// Define the base address of your slave device
#define SLAVE_BASE_ADDRESS XPAR_TEST_SPI_READ_0_S00_AXI_BASEADDR  // Replace with your slave's base address

// Define the register offset you want to read
#define REGISTER_OFFSET    0x00  // Replace with your register's offset

#ifdef INTR_EN
#define INTG_INTC_DEVICE_ID	XPAR_INTC_0_DEVICE_ID
// Define the Interrupt ID (replace with your actual ID)
#define CONFIG_DONE_INTERRUPT_ID 0U

// Interrupt controller instance
static XIntc InterruptController;

// Global flag to indicate interrupt occurred
volatile int data_ready = 0;
#endif // INTR_EN

int twos_complement(uint16_t value, int bits);

#ifdef INTR_EN
int intr_setup(void);

// Interrupt handler function
void IntrHandler(void *CallbackRef) {
    data_ready = 1;  // Set the flag to indicate interrupt occurred
}
#endif // INTR_EN

int main() {
    u32 register_value = 0;
    u32 register_value_aux = 0;
    // Calculate the full address of the register
    u32 register_address = SLAVE_BASE_ADDRESS + REGISTER_OFFSET;

    double double_reg = 0.0;

    int counter = 30000;

#ifdef INTR_EN
    // Set up the interrupt
    int err = intr_setup();
    if (err) {
        xil_printf("Interrupt config failed\n\r");
        return err;
    }

	// Wait for the config_done interrupt
	while (!config_done_flag);
	xil_printf("Configuration of ADXL313 done!\n\r");
#endif // INTR_EN

	// wait config done ~30000clk
    while(counter--);

#ifdef __DEBUG
    xil_printf("\n\rRegisters Values: \n\r");

    Xil_Out32(register_address+0x04, 0);
    register_value = Xil_In32(register_address);
    register_value_aux = register_value;
	// Print the register value
	xil_printf("[0x00] = 0x%X\n\r", (u8)register_value);

	Xil_Out32(register_address+0x04, 0x31);
	while(register_value_aux == register_value)	{
		register_value = Xil_In32(register_address);
	}
	register_value_aux = register_value;
	// Print the register value
	xil_printf("[0x31] = 0x%X\n\r", (u8)register_value);

	Xil_Out32(register_address+0x04, 0x2E);
	while(register_value_aux == register_value)	{
		register_value = Xil_In32(register_address);
	}
	register_value_aux = register_value;
	// Print the register value
	xil_printf("[0x2E] = 0x%X\n\r", (u8)register_value);

	Xil_Out32(register_address+0x04, 0x2D);
	while(register_value_aux == register_value)	{
		register_value = Xil_In32(register_address);
	}
	register_value_aux = register_value;
	// Print the register value
	xil_printf("[0x2D] = 0x%X\n\r", (u8)register_value);

	Xil_Out32(register_address+0x04, 0x2C);
	while(register_value_aux == register_value)	{
		register_value = Xil_In32(register_address);
	}
	register_value_aux = register_value;
	// Print the register value
	xil_printf("[0x2C] = 0x%X\n\r", (u8)register_value);

#endif //__DEBUG

	Xil_Out32(register_address+0x04, 0x32);
	while(1){
		register_value = Xil_In32(register_address);
		double_reg = (double) 100*twos_complement((uint16_t)register_value & 0x1FFF, 13) * (double)0.000976562;

		xil_printf("[0x32] = %d (0x%X)\n\r", (int) double_reg, (u16)register_value);
	}

    return 0;
}

#ifdef INTR_EN
    // Function to set up the interrupt
int intr_setup(void) {
	int Status;

	/* Initialize the interrupt controller and connect the ISRs */
	Status = XIntc_Initialize(&InterruptController, INTG_INTC_DEVICE_ID);
	if (Status != XST_SUCCESS)	{
		xil_printf("Failed init intc\r\n");
		return XST_FAILURE;
	}

	/*
	 * Connect the driver interrupt handler
	 */
	Status = XIntc_Connect(&InterruptController, CONFIG_DONE_INTERRUPT_ID,
				(XInterruptHandler)IntrHandler, NULL);
	if (Status != XST_SUCCESS)	{
		xil_printf("Failed connect intc\r\n");
		return XST_FAILURE;
	}

	/*
	 * Start the interrupt controller such that interrupts are enabled for
	 * all devices that cause interrupts.
	 */
	Status = XIntc_Start(&InterruptController, XIN_REAL_MODE);
	if (Status != XST_SUCCESS)
		return XST_FAILURE;

	/*
	 * Enable the interrupt for the CSUDMA device.
	 */
	XIntc_Enable(&InterruptController, CONFIG_DONE_INTERRUPT_ID);
	Xil_ExceptionInit();
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
				(Xil_ExceptionHandler)XIntc_InterruptHandler,
				(void *)&InterruptController);

	return XST_SUCCESS;
}
#endif // INTR_EN

int twos_complement(uint16_t value, int bits)
{
    int val = (int) value;

    if (val & (1 << (bits-1)))
        val -= 1 << bits;

    return val;
}
