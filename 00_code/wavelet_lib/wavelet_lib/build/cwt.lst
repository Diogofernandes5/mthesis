ARM GAS  /tmp/ccVCbso8.s 			page 1


   1              		.cpu cortex-m7
   2              		.eabi_attribute 28, 1
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 1
  11              		.eabi_attribute 18, 4
  12              		.file	"cwt.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.section	.rodata.cwt.str1.4,"aMS",%progbits,1
  17              		.align	2
  18              	.LC0:
  19 0000 54696D65 		.ascii	"Time series array length must be a power of 2!\012\015"
  19      20736572 
  19      69657320 
  19      61727261 
  19      79206C65 
  20 0030 00       		.ascii	"\000"
  21 0031 000000   		.align	2
  22              	.LC1:
  23 0034 49742077 		.ascii	"It was not possible to allocate 'y_aux' pointer!\012"
  23      6173206E 
  23      6F742070 
  23      6F737369 
  23      626C6520 
  24 0065 0D00     		.ascii	"\015\000"
  25 0067 00       		.align	2
  26              	.LC2:
  27 0068 49742077 		.ascii	"It was not possible to compute the FFT of time seri"
  27      6173206E 
  27      6F742070 
  27      6F737369 
  27      626C6520 
  28 009b 65732061 		.ascii	"es array!\012\015\000"
  28      72726179 
  28      210A0D00 
  29 00a7 00       		.align	2
  30              	.LC3:
  31 00a8 49742077 		.ascii	"It was not possible to allocate 'wk' pointer!\012\015"
  31      6173206E 
  31      6F742070 
  31      6F737369 
  31      626C6520 
  32 00d7 00       		.ascii	"\000"
  33              		.align	2
  34              	.LC4:
  35 00d8 49742077 		.ascii	"It was not possible to allocate 'daughter' pointer!"
  35      6173206E 
  35      6F742070 
  35      6F737369 
  35      626C6520 
ARM GAS  /tmp/ccVCbso8.s 			page 2


  36 010b 0A0D00   		.ascii	"\012\015\000"
  37 010e 0000     		.align	2
  38              	.LC5:
  39 0110 49742077 		.ascii	"It was not possible to compute scales wavelet!\012\015"
  39      6173206E 
  39      6F742070 
  39      6F737369 
  39      626C6520 
  40 0140 00       		.ascii	"\000"
  41 0141 000000   		.align	2
  42              	.LC6:
  43 0144 49742077 		.ascii	"It was not possible to compute the inverse fourier "
  43      6173206E 
  43      6F742070 
  43      6F737369 
  43      626C6520 
  44 0177 20202020 		.ascii	"                transform of the tranformed signal!"
  44      20202020 
  44      20202020 
  44      20202020 
  44      7472616E 
  45 01aa 0A0D00   		.ascii	"\012\015\000"
  46              		.section	.text.cwt,"ax",%progbits
  47              		.align	1
  48              		.global	cwt
  49              		.arch armv7e-m
  50              		.syntax unified
  51              		.thumb
  52              		.thumb_func
  53              		.fpu fpv5-d16
  55              	cwt:
  56              	.LVL0:
  57              	.LFB146:
  58              		.file 1 "../Core/Src/cwt.c"
   1:../Core/Src/cwt.c **** #include "cwt.h"
   2:../Core/Src/cwt.c **** 
   3:../Core/Src/cwt.c **** #include "wavelet.h"
   4:../Core/Src/cwt.c **** #include "fft.h" 
   5:../Core/Src/cwt.c **** #include "utils.h" // is_powerof2
   6:../Core/Src/cwt.c **** 
   7:../Core/Src/cwt.c **** #include "usart.h"
   8:../Core/Src/cwt.c **** #include "errdef.h"
   9:../Core/Src/cwt.c **** 
  10:../Core/Src/cwt.c **** #include <math.h>
  11:../Core/Src/cwt.c **** #include <stdint.h>
  12:../Core/Src/cwt.c **** #include <stdlib.h> // malloc
  13:../Core/Src/cwt.c **** 
  14:../Core/Src/cwt.c **** extern int (*wave_bases[1])(float *wk_i, uint32_t N_i, float scale_i, float param_i, 
  15:../Core/Src/cwt.c ****         float *daughter_o, float *fourier_factor_o, float *coi_o, uint8_t *dof_min_o);
  16:../Core/Src/cwt.c ****         // = {morlet_base}; //, null, null}; // morlet, paul, DOG
  17:../Core/Src/cwt.c **** 
  18:../Core/Src/cwt.c **** /**
  19:../Core/Src/cwt.c ****  * @brief   Computes the wavelet transform of the vector y_i (length N_i),
  20:../Core/Src/cwt.c ****  *              with sampling rate dt_i.
  21:../Core/Src/cwt.c ****  * 
  22:../Core/Src/cwt.c ****  * @param   y_i         - time series array to be computed (size N_i)
  23:../Core/Src/cwt.c ****  * @param   N_i         - time series array length (must be a power of 2)
ARM GAS  /tmp/ccVCbso8.s 			page 3


  24:../Core/Src/cwt.c ****  * @param   dt_i        - sampling period
  25:../Core/Src/cwt.c ****  * @param   dj_i        - spacing between scales 
  26:../Core/Src/cwt.c ****  * @param   s0_i        - smallest scale of the wavelet
  27:../Core/Src/cwt.c ****  * @param   J_i         - total number of scales (range = [s0_i, s0_i*2^(J_i*dj_i)])
  28:../Core/Src/cwt.c ****  * @param   mother_i    - mother wavelet (morlet, paul, dog)
  29:../Core/Src/cwt.c ****  * @param   param_i     - mother wavelet parameter
  30:../Core/Src/cwt.c ****  * 
  31:../Core/Src/cwt.c ****  * @param   y_cwt_o     - cwt applied in complex array with size (J_i x N_i)
  32:../Core/Src/cwt.c ****  * @param   period_o    - array of Fourier periods (in time units) 
  33:../Core/Src/cwt.c ****  *                            that corresponds to the scales
  34:../Core/Src/cwt.c ****  * @param   scale_o     - array of scale indices, given by s0_i*2^(j*dj_i),
  35:../Core/Src/cwt.c ****  *                            j = 0...J_i
  36:../Core/Src/cwt.c ****  * @param   coi_o       - array of N_i points containing the max period of useful
  37:../Core/Src/cwt.c ****  *                            information
  38:../Core/Src/cwt.c ****  * 
  39:../Core/Src/cwt.c ****  * @retval  Success
  40:../Core/Src/cwt.c ****  * */
  41:../Core/Src/cwt.c **** int cwt(complex *y_i, uint32_t N_i, float dt_i, float dj_i, float s0_i, uint32_t J_i, 
  42:../Core/Src/cwt.c ****             wavelet_funcs mother_i, float param_i,
  43:../Core/Src/cwt.c ****             complex *y_cwt_o, float *period_o, float *scale_o, float *coi_o)
  44:../Core/Src/cwt.c **** {
  59              		.loc 1 44 1 view -0
  60              		.cfi_startproc
  61              		@ args = 16, pretend = 0, frame = 24
  62              		@ frame_needed = 0, uses_anonymous_args = 0
  63              		.loc 1 44 1 is_stmt 0 view .LVU1
  64 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
  65              	.LCFI0:
  66              		.cfi_def_cfa_offset 36
  67              		.cfi_offset 4, -36
  68              		.cfi_offset 5, -32
  69              		.cfi_offset 6, -28
  70              		.cfi_offset 7, -24
  71              		.cfi_offset 8, -20
  72              		.cfi_offset 9, -16
  73              		.cfi_offset 10, -12
  74              		.cfi_offset 11, -8
  75              		.cfi_offset 14, -4
  76 0004 2DED068B 		vpush.64	{d8, d9, d10}
  77              	.LCFI1:
  78              		.cfi_def_cfa_offset 60
  79              		.cfi_offset 80, -60
  80              		.cfi_offset 81, -56
  81              		.cfi_offset 82, -52
  82              		.cfi_offset 83, -48
  83              		.cfi_offset 84, -44
  84              		.cfi_offset 85, -40
  85 0008 89B0     		sub	sp, sp, #36
  86              	.LCFI2:
  87              		.cfi_def_cfa_offset 96
  88 000a 8046     		mov	r8, r0
  89 000c 0C46     		mov	r4, r1
  90 000e B0EE40AA 		vmov.f32	s20, s0
  91 0012 B0EE608A 		vmov.f32	s16, s1
  92 0016 F0EE418A 		vmov.f32	s17, s2
  93 001a 0392     		str	r2, [sp, #12]
  94 001c 0493     		str	r3, [sp, #16]
ARM GAS  /tmp/ccVCbso8.s 			page 4


  95 001e B0EE619A 		vmov.f32	s18, s3
  96 0022 189E     		ldr	r6, [sp, #96]
  45:../Core/Src/cwt.c ****     uint8_t ret = 0;
  97              		.loc 1 45 5 is_stmt 1 view .LVU2
  98              	.LVL1:
  46:../Core/Src/cwt.c ****     uint32_t k; /* iterator */
  99              		.loc 1 46 5 view .LVU3
  47:../Core/Src/cwt.c ****     uint32_t j;
 100              		.loc 1 47 5 view .LVU4
  48:../Core/Src/cwt.c ****     // uint8_t *dof_min = (uint8_t*) malloc(sizeof(uint8_t));
  49:../Core/Src/cwt.c ****     uint8_t dof_min = 0;
 101              		.loc 1 49 5 view .LVU5
 102              		.loc 1 49 13 is_stmt 0 view .LVU6
 103 0024 0023     		movs	r3, #0
 104              	.LVL2:
 105              		.loc 1 49 13 view .LVU7
 106 0026 8DF81F30 		strb	r3, [sp, #31]
  50:../Core/Src/cwt.c ****     // float *fourier_factor = (float*) malloc(sizeof(float));
  51:../Core/Src/cwt.c ****     float fourier_factor = 0.0;
 107              		.loc 1 51 5 is_stmt 1 view .LVU8
 108              		.loc 1 51 11 is_stmt 0 view .LVU9
 109 002a 0023     		movs	r3, #0
 110 002c 0693     		str	r3, [sp, #24]	@ float
  52:../Core/Src/cwt.c **** 
  53:../Core/Src/cwt.c **** 	// verify power of 2 length
  54:../Core/Src/cwt.c **** 	if(!is_powerof2((float) N_i))
 111              		.loc 1 54 2 is_stmt 1 view .LVU10
 112              		.loc 1 54 18 is_stmt 0 view .LVU11
 113 002e 07EE901A 		vmov	s15, r1	@ int
 114 0032 F8EE679A 		vcvt.f32.u32	s19, s15
 115              		.loc 1 54 6 view .LVU12
 116 0036 BDEEE90A 		vcvt.s32.f32	s0, s19
 117              	.LVL3:
 118              	.LBB9:
 119              	.LBI9:
 120              		.file 2 "../Core/Inc/utils.h"
   1:../Core/Inc/utils.h **** /**
   2:../Core/Inc/utils.h ****  * @file   	utils.h
   3:../Core/Inc/utils.h ****  * @author 	Diogo Fernandes (diogo.cf20@gmail.com)
   4:../Core/Inc/utils.h ****  * */
   5:../Core/Inc/utils.h **** 
   6:../Core/Inc/utils.h **** #ifndef _UTILS_H_
   7:../Core/Inc/utils.h **** #define _UTILS_H_
   8:../Core/Inc/utils.h **** 
   9:../Core/Inc/utils.h **** #ifdef __cplusplus
  10:../Core/Inc/utils.h **** extern "C" {
  11:../Core/Inc/utils.h **** #endif
  12:../Core/Inc/utils.h **** 
  13:../Core/Inc/utils.h **** #include <stdint.h>
  14:../Core/Inc/utils.h **** #include <math.h> // -lm flag necessary
  15:../Core/Inc/utils.h **** 
  16:../Core/Inc/utils.h **** /******************************************************************************
  17:../Core/Inc/utils.h **** Defines and Macros
  18:../Core/Inc/utils.h **** ******************************************************************************/
  19:../Core/Inc/utils.h **** #ifndef PI
  20:../Core/Inc/utils.h **** # define PI 3.14159265358979323846264338327950288
  21:../Core/Inc/utils.h **** #endif
ARM GAS  /tmp/ccVCbso8.s 			page 5


  22:../Core/Inc/utils.h **** 
  23:../Core/Inc/utils.h **** #define IS_ADDR16(__addr16__)           ((uint32_t)(__addr16__) < 0x10000) // Valid for [0 - 0xFFFF
  24:../Core/Inc/utils.h **** #define IS_ADDR8(__addr8__)                 ((uint16_t)(__addr8__) < 0x100) // Valid for [0 - 0xFF]
  25:../Core/Inc/utils.h **** #define IS_ADDR4(__addr4__)                 ((uint8_t)(__addr4__) < 0x10)   // Valid for [0 - 0x0F]
  26:../Core/Inc/utils.h **** 
  27:../Core/Inc/utils.h **** #define IS_BIT_SET(_byte_, _nbit_)  (((_byte_)>>(_nbit_)) & 0x01)
  28:../Core/Inc/utils.h **** #define CLEARBIT(_byte_, _nbit_)        ((_byte_) &= ~(1<<(_nbit_)))
  29:../Core/Inc/utils.h **** //#define setbit(x,n)   x|=(1<<n)
  30:../Core/Inc/utils.h **** //#define togglebit(x,n)  x^=(1<<n)
  31:../Core/Inc/utils.h **** //#define isbitclear(x,n) !((x>>n) & 0x1)
  32:../Core/Inc/utils.h **** 
  33:../Core/Inc/utils.h **** #define IS_PRINTABLE(__ch__)    (((__ch__) > 0x1F) && ((__ch__) < 0x7F)) // Is true if __ch__ is a 
  34:../Core/Inc/utils.h **** 
  35:../Core/Inc/utils.h **** #define IS_DIG(__dig__)                         (((uint8_t)(__dig__) > 0x00) && ((uint8_t)(__dig__)
  36:../Core/Inc/utils.h **** 
  37:../Core/Inc/utils.h **** //typedef enum comm_operation {write = 0, read};
  38:../Core/Inc/utils.h **** 
  39:../Core/Inc/utils.h **** /******************************************************************************
  40:../Core/Inc/utils.h **** Function Prototypes
  41:../Core/Inc/utils.h **** ******************************************************************************/
  42:../Core/Inc/utils.h **** 
  43:../Core/Inc/utils.h **** int my_atoi(const char *str);
  44:../Core/Inc/utils.h **** 
  45:../Core/Inc/utils.h **** /******************************************************************************
  46:../Core/Inc/utils.h **** Function Definition
  47:../Core/Inc/utils.h **** ******************************************************************************/
  48:../Core/Inc/utils.h **** 
  49:../Core/Inc/utils.h **** /**
  50:../Core/Inc/utils.h ****  * @brief   Verifies if val is integer
  51:../Core/Inc/utils.h ****  * 
  52:../Core/Inc/utils.h ****  * @param   val -number to verify
  53:../Core/Inc/utils.h ****  * 
  54:../Core/Inc/utils.h ****  * @retval  yes (1) / no (0) 
  55:../Core/Inc/utils.h ****  * */
  56:../Core/Inc/utils.h **** static inline uint8_t isInteger(double val)
  57:../Core/Inc/utils.h **** {
  58:../Core/Inc/utils.h ****     int truncated = (int)val;
  59:../Core/Inc/utils.h ****     return (val == truncated);
  60:../Core/Inc/utils.h **** }
  61:../Core/Inc/utils.h **** 
  62:../Core/Inc/utils.h **** /**
  63:../Core/Inc/utils.h ****  * @brief   Verifies if n is power of 2 number
  64:../Core/Inc/utils.h ****  * 
  65:../Core/Inc/utils.h ****  * @param   n - number to verify
  66:../Core/Inc/utils.h ****  * 
  67:../Core/Inc/utils.h ****  * @retval  yes (1) / no (0) 
  68:../Core/Inc/utils.h ****  * */
  69:../Core/Inc/utils.h **** static inline uint8_t is_powerof2(int n)
 121              		.loc 2 69 23 is_stmt 1 view .LVU13
 122              	.LBB10:
  70:../Core/Inc/utils.h **** {
  71:../Core/Inc/utils.h ****     double log_n = (log(n)/log(2));
 123              		.loc 2 71 5 view .LVU14
 124              		.loc 2 71 21 is_stmt 0 view .LVU15
 125 003a B8EEC00B 		vcvt.f64.s32	d0, s0
 126              	.LVL4:
 127              		.loc 2 71 21 view .LVU16
ARM GAS  /tmp/ccVCbso8.s 			page 6


 128 003e FFF7FEFF 		bl	log
 129              	.LVL5:
 130              		.loc 2 71 12 view .LVU17
 131 0042 9FED7F7B 		vldr.64	d7, .L27
 132 0046 80EE076B 		vdiv.f64	d6, d0, d7
 133              	.LVL6:
  72:../Core/Inc/utils.h ****     return isInteger(log_n);
 134              		.loc 2 72 5 is_stmt 1 view .LVU18
 135              	.LBB11:
 136              	.LBI11:
  56:../Core/Inc/utils.h **** {
 137              		.loc 2 56 23 view .LVU19
 138              	.LBB12:
  58:../Core/Inc/utils.h ****     return (val == truncated);
 139              		.loc 2 58 5 view .LVU20
  58:../Core/Inc/utils.h ****     return (val == truncated);
 140              		.loc 2 58 9 is_stmt 0 view .LVU21
 141 004a BDEEC67B 		vcvt.s32.f64	s14, d6
 142              	.LVL7:
  59:../Core/Inc/utils.h **** }
 143              		.loc 2 59 5 is_stmt 1 view .LVU22
  59:../Core/Inc/utils.h **** }
 144              		.loc 2 59 17 is_stmt 0 view .LVU23
 145 004e B8EEC77B 		vcvt.f64.s32	d7, s14
 146              	.LVL8:
  59:../Core/Inc/utils.h **** }
 147              		.loc 2 59 17 view .LVU24
 148              	.LBE12:
 149              	.LBE11:
 150              	.LBE10:
 151              	.LBE9:
 152              		.loc 1 54 4 view .LVU25
 153 0052 B4EE467B 		vcmp.f64	d7, d6
 154 0056 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 155 005a 26D1     		bne	.L19
  55:../Core/Src/cwt.c **** 	{
  56:../Core/Src/cwt.c **** 		// or you can pad the array with zeros until the neareast greater power of 2
  57:../Core/Src/cwt.c ****         // this will increase the frequency resolution 
  58:../Core/Src/cwt.c **** 		UART_puts("Time series array length must be a power of 2!\n\r");
  59:../Core/Src/cwt.c **** 		return _EXIT_FAILURE;
  60:../Core/Src/cwt.c **** 	}
  61:../Core/Src/cwt.c **** 
  62:../Core/Src/cwt.c ****     uint16_t half_N_i = (uint16_t) (N_i >> 1); /* half lenght of the time 
 156              		.loc 1 62 5 is_stmt 1 view .LVU26
 157              		.loc 1 62 41 is_stmt 0 view .LVU27
 158 005c 6508     		lsrs	r5, r4, #1
 159              	.LVL9:
  63:../Core/Src/cwt.c ****                                                     series array */
  64:../Core/Src/cwt.c ****     
  65:../Core/Src/cwt.c ****     /* Compute FFT of time series array - Equation 3 */
  66:../Core/Src/cwt.c ****     complex *y_aux = (complex *) calloc(N_i, sizeof(complex)); /* auxliary empty array */
 160              		.loc 1 66 5 is_stmt 1 view .LVU28
 161              		.loc 1 66 34 is_stmt 0 view .LVU29
 162 005e 1021     		movs	r1, #16
 163 0060 2046     		mov	r0, r4
 164 0062 FFF7FEFF 		bl	calloc
 165              	.LVL10:
ARM GAS  /tmp/ccVCbso8.s 			page 7


  67:../Core/Src/cwt.c ****     if(y_aux == NULL)
 166              		.loc 1 67 5 is_stmt 1 view .LVU30
 167              		.loc 1 67 7 is_stmt 0 view .LVU31
 168 0066 0290     		str	r0, [sp, #8]
 169 0068 40B3     		cbz	r0, .L20
  68:../Core/Src/cwt.c ****     {
  69:../Core/Src/cwt.c ****         UART_puts("It was not possible to allocate 'y_aux' pointer!\n\r");
  70:../Core/Src/cwt.c ****         return -ENOMEM;
  71:../Core/Src/cwt.c ****     }
  72:../Core/Src/cwt.c ****     memset(y_aux, 0, N_i);
 170              		.loc 1 72 5 is_stmt 1 view .LVU32
 171 006a 2246     		mov	r2, r4
 172 006c 0021     		movs	r1, #0
 173 006e 029F     		ldr	r7, [sp, #8]
 174 0070 3846     		mov	r0, r7
 175              		.loc 1 72 5 is_stmt 0 view .LVU33
 176 0072 FFF7FEFF 		bl	memset
 177              	.LVL11:
  73:../Core/Src/cwt.c **** 
  74:../Core/Src/cwt.c ****     ret = fft(y_i, N_i, y_aux);
 178              		.loc 1 74 5 is_stmt 1 view .LVU34
 179              		.loc 1 74 11 is_stmt 0 view .LVU35
 180 0076 3A46     		mov	r2, r7
 181 0078 2146     		mov	r1, r4
 182 007a 4046     		mov	r0, r8
 183 007c FFF7FEFF 		bl	fft
 184              	.LVL12:
  75:../Core/Src/cwt.c ****     if(ret)
 185              		.loc 1 75 5 is_stmt 1 view .LVU36
 186              		.loc 1 75 7 is_stmt 0 view .LVU37
 187 0080 10BB     		cbnz	r0, .L21
  76:../Core/Src/cwt.c ****     {
  77:../Core/Src/cwt.c ****         UART_puts("It was not possible to compute the FFT of time series array!\n\r");
  78:../Core/Src/cwt.c ****         return _EXIT_FAILURE;
  79:../Core/Src/cwt.c ****     }
  80:../Core/Src/cwt.c **** 
  81:../Core/Src/cwt.c ****     /* Construct wavenumber array used in transform - Equation 5 */
  82:../Core/Src/cwt.c ****     /* NOTE: in Torrence's paper this is done in another way
  83:../Core/Src/cwt.c ****         where after half array, the wk is descending negatively */
  84:../Core/Src/cwt.c ****     float *wk = (float*) calloc(N_i, sizeof(float));
 188              		.loc 1 84 5 is_stmt 1 view .LVU38
 189              		.loc 1 84 26 is_stmt 0 view .LVU39
 190 0082 0421     		movs	r1, #4
 191 0084 2046     		mov	r0, r4
 192              	.LVL13:
 193              		.loc 1 84 26 view .LVU40
 194 0086 FFF7FEFF 		bl	calloc
 195              	.LVL14:
  85:../Core/Src/cwt.c ****     if(wk == NULL)
 196              		.loc 1 85 5 is_stmt 1 view .LVU41
 197              		.loc 1 85 7 is_stmt 0 view .LVU42
 198 008a 8346     		mov	fp, r0
 199 008c 08B3     		cbz	r0, .L22
  86:../Core/Src/cwt.c ****     {
  87:../Core/Src/cwt.c ****         UART_puts("It was not possible to allocate 'wk' pointer!\n\r");
  88:../Core/Src/cwt.c ****         return -ENOMEM;
  89:../Core/Src/cwt.c ****     }
ARM GAS  /tmp/ccVCbso8.s 			page 8


  90:../Core/Src/cwt.c **** 
  91:../Core/Src/cwt.c ****     float multiplier_aux = (2 * M_PI) / (N_i * dt_i);
 200              		.loc 1 91 5 is_stmt 1 view .LVU43
 201              		.loc 1 91 46 is_stmt 0 view .LVU44
 202 008e 29EE8A6A 		vmul.f32	s12, s19, s20
 203 0092 B7EEC66A 		vcvt.f64.f32	d6, s12
 204              		.loc 1 91 39 view .LVU45
 205 0096 9FED6C5B 		vldr.64	d5, .L27+8
 206 009a 85EE067B 		vdiv.f64	d7, d5, d6
 207              		.loc 1 91 11 view .LVU46
 208 009e B7EEC77B 		vcvt.f32.f64	s14, d7
 209              	.LVL15:
  92:../Core/Src/cwt.c **** 
  93:../Core/Src/cwt.c ****     /* k <= N/2 */
  94:../Core/Src/cwt.c ****     wk[0] = 0;
 210              		.loc 1 94 5 is_stmt 1 view .LVU47
 211              		.loc 1 94 11 is_stmt 0 view .LVU48
 212 00a2 0023     		movs	r3, #0
 213 00a4 0360     		str	r3, [r0]	@ float
  95:../Core/Src/cwt.c ****     for(k = 1; k < half_N_i + 1; k++)
 214              		.loc 1 95 5 is_stmt 1 view .LVU49
 215              	.LVL16:
 216              		.loc 1 95 11 is_stmt 0 view .LVU50
 217 00a6 0123     		movs	r3, #1
 218              		.loc 1 95 5 view .LVU51
 219 00a8 24E0     		b	.L7
 220              	.LVL17:
 221              	.L19:
  58:../Core/Src/cwt.c **** 		return _EXIT_FAILURE;
 222              		.loc 1 58 3 is_stmt 1 view .LVU52
 223 00aa 6B48     		ldr	r0, .L27+24
 224 00ac FFF7FEFF 		bl	UART_puts
 225              	.LVL18:
  59:../Core/Src/cwt.c **** 	}
 226              		.loc 1 59 3 view .LVU53
  59:../Core/Src/cwt.c **** 	}
 227              		.loc 1 59 10 is_stmt 0 view .LVU54
 228 00b0 0120     		movs	r0, #1
 229              	.LVL19:
 230              	.L1:
  96:../Core/Src/cwt.c ****     {
  97:../Core/Src/cwt.c ****         wk[k] = multiplier_aux * k;
  98:../Core/Src/cwt.c ****     }
  99:../Core/Src/cwt.c **** 
 100:../Core/Src/cwt.c ****     /* k > N/2 */
 101:../Core/Src/cwt.c ****     for(k = 1; k < half_N_i; k++)
 102:../Core/Src/cwt.c ****     {
 103:../Core/Src/cwt.c ****         wk[N_i - k] = - multiplier_aux * k;
 104:../Core/Src/cwt.c ****     //     wk[k] = multiplier_aux * (k - half_N_i + 1);
 105:../Core/Src/cwt.c ****     }
 106:../Core/Src/cwt.c **** 
 107:../Core/Src/cwt.c ****     float *daughter = (float*) calloc(N_i, sizeof(float));
 108:../Core/Src/cwt.c ****     if(daughter == NULL)
 109:../Core/Src/cwt.c ****     {
 110:../Core/Src/cwt.c ****         UART_puts("It was not possible to allocate 'daughter' pointer!\n\r");
 111:../Core/Src/cwt.c ****         return -ENOMEM;
 112:../Core/Src/cwt.c ****     }
ARM GAS  /tmp/ccVCbso8.s 			page 9


 113:../Core/Src/cwt.c **** 
 114:../Core/Src/cwt.c ****     /* Loop through scales */
 115:../Core/Src/cwt.c ****     for(j = 0; j < J_i; j++)
 116:../Core/Src/cwt.c ****     {
 117:../Core/Src/cwt.c ****         scale_o[j] = s0_i * pow(2, (j * dj_i));
 118:../Core/Src/cwt.c **** 
 119:../Core/Src/cwt.c ****         ret = wave_bases[mother_i](wk, N_i, scale_o[j], param_i, 
 120:../Core/Src/cwt.c ****             daughter, &fourier_factor, coi_o, &dof_min);
 121:../Core/Src/cwt.c **** 
 122:../Core/Src/cwt.c ****         if(ret)
 123:../Core/Src/cwt.c ****         {
 124:../Core/Src/cwt.c ****             UART_puts("It was not possible to compute scales wavelet!\n\r");
 125:../Core/Src/cwt.c ****             return _EXIT_FAILURE;
 126:../Core/Src/cwt.c ****         }
 127:../Core/Src/cwt.c **** 
 128:../Core/Src/cwt.c ****         for(uint32_t i = 0; i < N_i; i++)
 129:../Core/Src/cwt.c ****         {
 130:../Core/Src/cwt.c ****             y_cwt_o[(j * N_i) + i].Re = complex_mul_re(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 131:../Core/Src/cwt.c ****             y_cwt_o[(j * N_i) + i].Im = complex_mul_im(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 132:../Core/Src/cwt.c ****         }
 133:../Core/Src/cwt.c **** 
 134:../Core/Src/cwt.c ****         ret = ifft(&y_cwt_o[j], N_i, y_aux);
 135:../Core/Src/cwt.c **** 
 136:../Core/Src/cwt.c ****         if(ret)
 137:../Core/Src/cwt.c ****         {
 138:../Core/Src/cwt.c ****             UART_puts("It was not possible to compute the inverse fourier \
 139:../Core/Src/cwt.c ****                 transform of the tranformed signal!\n\r");
 140:../Core/Src/cwt.c ****             return _EXIT_FAILURE;
 141:../Core/Src/cwt.c ****         }
 142:../Core/Src/cwt.c **** 
 143:../Core/Src/cwt.c ****         period_o[j] = fourier_factor * scale_o[j];
 144:../Core/Src/cwt.c ****     }
 145:../Core/Src/cwt.c **** 
 146:../Core/Src/cwt.c ****     /* Free memory space */
 147:../Core/Src/cwt.c ****     free(y_aux);
 148:../Core/Src/cwt.c **** 
 149:../Core/Src/cwt.c ****     free(wk);
 150:../Core/Src/cwt.c ****     free(daughter);
 151:../Core/Src/cwt.c **** 
 152:../Core/Src/cwt.c ****     return _EXIT_SUCCESS;
 153:../Core/Src/cwt.c **** }...
 231              		.loc 1 153 1 view .LVU55
 232 00b2 09B0     		add	sp, sp, #36
 233              	.LCFI3:
 234              		.cfi_remember_state
 235              		.cfi_def_cfa_offset 60
 236              		@ sp needed
 237 00b4 BDEC068B 		vldm	sp!, {d8-d10}
 238              	.LCFI4:
 239              		.cfi_restore 84
 240              		.cfi_restore 85
 241              		.cfi_restore 82
 242              		.cfi_restore 83
 243              		.cfi_restore 80
 244              		.cfi_restore 81
 245              		.cfi_def_cfa_offset 36
 246              	.LVL20:
ARM GAS  /tmp/ccVCbso8.s 			page 10


 247              		.loc 1 153 1 view .LVU56
 248 00b8 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 249              	.LVL21:
 250              	.L20:
 251              	.LCFI5:
 252              		.cfi_restore_state
  69:../Core/Src/cwt.c ****         UART_puts("It was not possible to allocate 'y_aux' pointer!\n\r");
 253              		.loc 1 69 9 is_stmt 1 view .LVU57
 254 00bc 6748     		ldr	r0, .L27+28
 255              	.LVL22:
  69:../Core/Src/cwt.c ****         UART_puts("It was not possible to allocate 'y_aux' pointer!\n\r");
 256              		.loc 1 69 9 is_stmt 0 view .LVU58
 257 00be FFF7FEFF 		bl	UART_puts
 258              	.LVL23:
  70:../Core/Src/cwt.c ****         return -ENOMEM;
 259              		.loc 1 70 9 is_stmt 1 view .LVU59
  70:../Core/Src/cwt.c ****         return -ENOMEM;
 260              		.loc 1 70 16 is_stmt 0 view .LVU60
 261 00c2 6FF00400 		mvn	r0, #4
 262 00c6 F4E7     		b	.L1
 263              	.LVL24:
 264              	.L21:
  77:../Core/Src/cwt.c ****         UART_puts("It was not possible to compute the FFT of time series array!\n\r");
 265              		.loc 1 77 9 is_stmt 1 view .LVU61
 266 00c8 6548     		ldr	r0, .L27+32
 267              	.LVL25:
  77:../Core/Src/cwt.c ****         UART_puts("It was not possible to compute the FFT of time series array!\n\r");
 268              		.loc 1 77 9 is_stmt 0 view .LVU62
 269 00ca FFF7FEFF 		bl	UART_puts
 270              	.LVL26:
  78:../Core/Src/cwt.c ****         return _EXIT_FAILURE;
 271              		.loc 1 78 9 is_stmt 1 view .LVU63
  78:../Core/Src/cwt.c ****         return _EXIT_FAILURE;
 272              		.loc 1 78 16 is_stmt 0 view .LVU64
 273 00ce 0120     		movs	r0, #1
 274 00d0 EFE7     		b	.L1
 275              	.LVL27:
 276              	.L22:
  87:../Core/Src/cwt.c ****         UART_puts("It was not possible to allocate 'wk' pointer!\n\r");
 277              		.loc 1 87 9 is_stmt 1 view .LVU65
 278 00d2 6448     		ldr	r0, .L27+36
 279              	.LVL28:
  87:../Core/Src/cwt.c ****         UART_puts("It was not possible to allocate 'wk' pointer!\n\r");
 280              		.loc 1 87 9 is_stmt 0 view .LVU66
 281 00d4 FFF7FEFF 		bl	UART_puts
 282              	.LVL29:
  88:../Core/Src/cwt.c ****         return -ENOMEM;
 283              		.loc 1 88 9 is_stmt 1 view .LVU67
  88:../Core/Src/cwt.c ****         return -ENOMEM;
 284              		.loc 1 88 16 is_stmt 0 view .LVU68
 285 00d8 6FF00400 		mvn	r0, #4
 286 00dc E9E7     		b	.L1
 287              	.LVL30:
 288              	.L8:
  97:../Core/Src/cwt.c ****         wk[k] = multiplier_aux * k;
 289              		.loc 1 97 9 is_stmt 1 discriminator 3 view .LVU69
  97:../Core/Src/cwt.c ****         wk[k] = multiplier_aux * k;
ARM GAS  /tmp/ccVCbso8.s 			page 11


 290              		.loc 1 97 11 is_stmt 0 discriminator 3 view .LVU70
 291 00de 0BEB8302 		add	r2, fp, r3, lsl #2
  97:../Core/Src/cwt.c ****         wk[k] = multiplier_aux * k;
 292              		.loc 1 97 32 discriminator 3 view .LVU71
 293 00e2 07EE903A 		vmov	s15, r3	@ int
 294 00e6 F8EE677A 		vcvt.f32.u32	s15, s15
 295 00ea 67EE877A 		vmul.f32	s15, s15, s14
  97:../Core/Src/cwt.c ****         wk[k] = multiplier_aux * k;
 296              		.loc 1 97 15 discriminator 3 view .LVU72
 297 00ee C2ED007A 		vstr.32	s15, [r2]
  95:../Core/Src/cwt.c ****     for(k = 1; k < half_N_i + 1; k++)
 298              		.loc 1 95 34 is_stmt 1 discriminator 3 view .LVU73
  95:../Core/Src/cwt.c ****     for(k = 1; k < half_N_i + 1; k++)
 299              		.loc 1 95 35 is_stmt 0 discriminator 3 view .LVU74
 300 00f2 0133     		adds	r3, r3, #1
 301              	.LVL31:
 302              	.L7:
  95:../Core/Src/cwt.c ****     for(k = 1; k < half_N_i + 1; k++)
 303              		.loc 1 95 16 is_stmt 1 discriminator 1 view .LVU75
 304 00f4 A9B2     		uxth	r1, r5
  95:../Core/Src/cwt.c ****     for(k = 1; k < half_N_i + 1; k++)
 305              		.loc 1 95 29 is_stmt 0 discriminator 1 view .LVU76
 306 00f6 4A1C     		adds	r2, r1, #1
  95:../Core/Src/cwt.c ****     for(k = 1; k < half_N_i + 1; k++)
 307              		.loc 1 95 5 discriminator 1 view .LVU77
 308 00f8 9A42     		cmp	r2, r3
 309 00fa F0D8     		bhi	.L8
 101:../Core/Src/cwt.c ****     for(k = 1; k < half_N_i; k++)
 310              		.loc 1 101 11 view .LVU78
 311 00fc 0123     		movs	r3, #1
 312              	.LVL32:
 101:../Core/Src/cwt.c ****     for(k = 1; k < half_N_i; k++)
 313              		.loc 1 101 11 view .LVU79
 314 00fe 0BE0     		b	.L9
 315              	.LVL33:
 316              	.L10:
 103:../Core/Src/cwt.c ****         wk[N_i - k] = - multiplier_aux * k;
 317              		.loc 1 103 9 is_stmt 1 discriminator 3 view .LVU80
 103:../Core/Src/cwt.c ****         wk[N_i - k] = - multiplier_aux * k;
 318              		.loc 1 103 16 is_stmt 0 discriminator 3 view .LVU81
 319 0100 E21A     		subs	r2, r4, r3
 103:../Core/Src/cwt.c ****         wk[N_i - k] = - multiplier_aux * k;
 320              		.loc 1 103 11 discriminator 3 view .LVU82
 321 0102 0BEB8202 		add	r2, fp, r2, lsl #2
 103:../Core/Src/cwt.c ****         wk[N_i - k] = - multiplier_aux * k;
 322              		.loc 1 103 40 discriminator 3 view .LVU83
 323 0106 07EE903A 		vmov	s15, r3	@ int
 324 010a F8EE677A 		vcvt.f32.u32	s15, s15
 325 010e 67EE677A 		vnmul.f32	s15, s14, s15
 103:../Core/Src/cwt.c ****         wk[N_i - k] = - multiplier_aux * k;
 326              		.loc 1 103 21 discriminator 3 view .LVU84
 327 0112 C2ED007A 		vstr.32	s15, [r2]
 101:../Core/Src/cwt.c ****     for(k = 1; k < half_N_i; k++)
 328              		.loc 1 101 30 is_stmt 1 discriminator 3 view .LVU85
 101:../Core/Src/cwt.c ****     for(k = 1; k < half_N_i; k++)
 329              		.loc 1 101 31 is_stmt 0 discriminator 3 view .LVU86
 330 0116 0133     		adds	r3, r3, #1
ARM GAS  /tmp/ccVCbso8.s 			page 12


 331              	.LVL34:
 332              	.L9:
 101:../Core/Src/cwt.c ****     for(k = 1; k < half_N_i; k++)
 333              		.loc 1 101 16 is_stmt 1 discriminator 1 view .LVU87
 101:../Core/Src/cwt.c ****     for(k = 1; k < half_N_i; k++)
 334              		.loc 1 101 5 is_stmt 0 discriminator 1 view .LVU88
 335 0118 8B42     		cmp	r3, r1
 336 011a F1D3     		bcc	.L10
 107:../Core/Src/cwt.c ****     float *daughter = (float*) calloc(N_i, sizeof(float));
 337              		.loc 1 107 5 is_stmt 1 view .LVU89
 107:../Core/Src/cwt.c ****     float *daughter = (float*) calloc(N_i, sizeof(float));
 338              		.loc 1 107 32 is_stmt 0 view .LVU90
 339 011c 0421     		movs	r1, #4
 340 011e 2046     		mov	r0, r4
 341              	.LVL35:
 107:../Core/Src/cwt.c ****     float *daughter = (float*) calloc(N_i, sizeof(float));
 342              		.loc 1 107 32 view .LVU91
 343 0120 FFF7FEFF 		bl	calloc
 344              	.LVL36:
 108:../Core/Src/cwt.c ****     if(daughter == NULL)
 345              		.loc 1 108 5 is_stmt 1 view .LVU92
 108:../Core/Src/cwt.c ****     if(daughter == NULL)
 346              		.loc 1 108 7 is_stmt 0 view .LVU93
 347 0124 0746     		mov	r7, r0
 348              	.LVL37:
 108:../Core/Src/cwt.c ****     if(daughter == NULL)
 349              		.loc 1 108 7 view .LVU94
 350 0126 18B1     		cbz	r0, .L23
 115:../Core/Src/cwt.c ****     for(j = 0; j < J_i; j++)
 351              		.loc 1 115 11 view .LVU95
 352 0128 0025     		movs	r5, #0
 353              	.LVL38:
 115:../Core/Src/cwt.c ****     for(j = 0; j < J_i; j++)
 354              		.loc 1 115 11 view .LVU96
 355 012a CDF814B0 		str	fp, [sp, #20]
 356 012e 42E0     		b	.L11
 357              	.LVL39:
 358              	.L23:
 110:../Core/Src/cwt.c ****         UART_puts("It was not possible to allocate 'daughter' pointer!\n\r");
 359              		.loc 1 110 9 is_stmt 1 view .LVU97
 360 0130 4D48     		ldr	r0, .L27+40
 361              	.LVL40:
 110:../Core/Src/cwt.c ****         UART_puts("It was not possible to allocate 'daughter' pointer!\n\r");
 362              		.loc 1 110 9 is_stmt 0 view .LVU98
 363 0132 FFF7FEFF 		bl	UART_puts
 364              	.LVL41:
 111:../Core/Src/cwt.c ****         return -ENOMEM;
 365              		.loc 1 111 9 is_stmt 1 view .LVU99
 111:../Core/Src/cwt.c ****         return -ENOMEM;
 366              		.loc 1 111 16 is_stmt 0 view .LVU100
 367 0136 6FF00400 		mvn	r0, #4
 368 013a BAE7     		b	.L1
 369              	.LVL42:
 370              	.L26:
 124:../Core/Src/cwt.c ****             UART_puts("It was not possible to compute scales wavelet!\n\r");
 371              		.loc 1 124 13 is_stmt 1 view .LVU101
 372 013c 4B48     		ldr	r0, .L27+44
ARM GAS  /tmp/ccVCbso8.s 			page 13


 373              	.LVL43:
 124:../Core/Src/cwt.c ****             UART_puts("It was not possible to compute scales wavelet!\n\r");
 374              		.loc 1 124 13 is_stmt 0 view .LVU102
 375 013e FFF7FEFF 		bl	UART_puts
 376              	.LVL44:
 125:../Core/Src/cwt.c ****             return _EXIT_FAILURE;
 377              		.loc 1 125 13 is_stmt 1 view .LVU103
 125:../Core/Src/cwt.c ****             return _EXIT_FAILURE;
 378              		.loc 1 125 20 is_stmt 0 view .LVU104
 379 0142 0120     		movs	r0, #1
 380 0144 B5E7     		b	.L1
 381              	.LVL45:
 382              	.L13:
 383              	.LBB13:
 130:../Core/Src/cwt.c ****             y_cwt_o[(j * N_i) + i].Re = complex_mul_re(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 384              		.loc 1 130 13 is_stmt 1 discriminator 3 view .LVU105
 130:../Core/Src/cwt.c ****             y_cwt_o[(j * N_i) + i].Re = complex_mul_re(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 385              		.loc 1 130 41 is_stmt 0 discriminator 3 view .LVU106
 386 0146 08EB0311 		add	r1, r8, r3, lsl #4
 387 014a 91ED005B 		vldr.64	d5, [r1]
 388 014e 07EB8302 		add	r2, r7, r3, lsl #2
 389 0152 92ED007A 		vldr.32	s14, [r2]
 390 0156 B7EEC74A 		vcvt.f64.f32	d4, s14
 391 015a 91ED026B 		vldr.64	d6, [r1, #8]
 392 015e 9FED3C3B 		vldr.64	d3, .L27+16
 393 0162 26EE036B 		vmul.f64	d6, d6, d3
 130:../Core/Src/cwt.c ****             y_cwt_o[(j * N_i) + i].Re = complex_mul_re(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 394              		.loc 1 130 31 discriminator 3 view .LVU107
 395 0166 04FB0532 		mla	r2, r4, r5, r3
 130:../Core/Src/cwt.c ****             y_cwt_o[(j * N_i) + i].Re = complex_mul_re(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 396              		.loc 1 130 20 discriminator 3 view .LVU108
 397 016a 06EB0212 		add	r2, r6, r2, lsl #4
 130:../Core/Src/cwt.c ****             y_cwt_o[(j * N_i) + i].Re = complex_mul_re(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 398              		.loc 1 130 41 discriminator 3 view .LVU109
 399 016e 15EE046B 		vnmls.f64	d6, d5, d4
 130:../Core/Src/cwt.c ****             y_cwt_o[(j * N_i) + i].Re = complex_mul_re(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 400              		.loc 1 130 39 discriminator 3 view .LVU110
 401 0172 82ED006B 		vstr.64	d6, [r2]
 131:../Core/Src/cwt.c ****             y_cwt_o[(j * N_i) + i].Im = complex_mul_im(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 402              		.loc 1 131 13 is_stmt 1 discriminator 3 view .LVU111
 131:../Core/Src/cwt.c ****             y_cwt_o[(j * N_i) + i].Im = complex_mul_im(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 403              		.loc 1 131 41 is_stmt 0 discriminator 3 view .LVU112
 404 0176 91ED006B 		vldr.64	d6, [r1]
 405 017a 91ED027B 		vldr.64	d7, [r1, #8]
 406 017e 27EE047B 		vmul.f64	d7, d7, d4
 407 0182 06EE037B 		vmla.f64	d7, d6, d3
 131:../Core/Src/cwt.c ****             y_cwt_o[(j * N_i) + i].Im = complex_mul_im(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 408              		.loc 1 131 39 discriminator 3 view .LVU113
 409 0186 82ED027B 		vstr.64	d7, [r2, #8]
 128:../Core/Src/cwt.c ****         for(uint32_t i = 0; i < N_i; i++)
 410              		.loc 1 128 38 is_stmt 1 discriminator 3 view .LVU114
 128:../Core/Src/cwt.c ****         for(uint32_t i = 0; i < N_i; i++)
 411              		.loc 1 128 39 is_stmt 0 discriminator 3 view .LVU115
 412 018a 0133     		adds	r3, r3, #1
 413              	.LVL46:
 414              	.L12:
 128:../Core/Src/cwt.c ****         for(uint32_t i = 0; i < N_i; i++)
ARM GAS  /tmp/ccVCbso8.s 			page 14


 415              		.loc 1 128 29 is_stmt 1 discriminator 1 view .LVU116
 128:../Core/Src/cwt.c ****         for(uint32_t i = 0; i < N_i; i++)
 416              		.loc 1 128 9 is_stmt 0 discriminator 1 view .LVU117
 417 018c A342     		cmp	r3, r4
 418 018e DAD3     		bcc	.L13
 419              	.LBE13:
 134:../Core/Src/cwt.c ****         ret = ifft(&y_cwt_o[j], N_i, y_aux);
 420              		.loc 1 134 9 is_stmt 1 view .LVU118
 134:../Core/Src/cwt.c ****         ret = ifft(&y_cwt_o[j], N_i, y_aux);
 421              		.loc 1 134 15 is_stmt 0 view .LVU119
 422 0190 029A     		ldr	r2, [sp, #8]
 423 0192 2146     		mov	r1, r4
 424 0194 06EB0510 		add	r0, r6, r5, lsl #4
 425              	.LVL47:
 134:../Core/Src/cwt.c ****         ret = ifft(&y_cwt_o[j], N_i, y_aux);
 426              		.loc 1 134 15 view .LVU120
 427 0198 FFF7FEFF 		bl	ifft
 428              	.LVL48:
 136:../Core/Src/cwt.c ****         if(ret)
 429              		.loc 1 136 9 is_stmt 1 view .LVU121
 136:../Core/Src/cwt.c ****         if(ret)
 430              		.loc 1 136 11 is_stmt 0 view .LVU122
 431 019c 0028     		cmp	r0, #0
 432 019e 3BD1     		bne	.L24
 143:../Core/Src/cwt.c ****         period_o[j] = fourier_factor * scale_o[j];
 433              		.loc 1 143 9 is_stmt 1 discriminator 2 view .LVU123
 143:../Core/Src/cwt.c ****         period_o[j] = fourier_factor * scale_o[j];
 434              		.loc 1 143 47 is_stmt 0 discriminator 2 view .LVU124
 435 01a0 DAED007A 		vldr.32	s15, [r10]
 143:../Core/Src/cwt.c ****         period_o[j] = fourier_factor * scale_o[j];
 436              		.loc 1 143 17 discriminator 2 view .LVU125
 437 01a4 199B     		ldr	r3, [sp, #100]
 438 01a6 9944     		add	r9, r9, r3
 143:../Core/Src/cwt.c ****         period_o[j] = fourier_factor * scale_o[j];
 439              		.loc 1 143 38 discriminator 2 view .LVU126
 440 01a8 9DED067A 		vldr.32	s14, [sp, #24]
 441 01ac 67EE877A 		vmul.f32	s15, s15, s14
 143:../Core/Src/cwt.c ****         period_o[j] = fourier_factor * scale_o[j];
 442              		.loc 1 143 21 discriminator 2 view .LVU127
 443 01b0 C9ED007A 		vstr.32	s15, [r9]
 115:../Core/Src/cwt.c ****     for(j = 0; j < J_i; j++)
 444              		.loc 1 115 25 is_stmt 1 discriminator 2 view .LVU128
 115:../Core/Src/cwt.c ****     for(j = 0; j < J_i; j++)
 445              		.loc 1 115 26 is_stmt 0 discriminator 2 view .LVU129
 446 01b4 0135     		adds	r5, r5, #1
 447              	.LVL49:
 448              	.L11:
 115:../Core/Src/cwt.c ****     for(j = 0; j < J_i; j++)
 449              		.loc 1 115 16 is_stmt 1 discriminator 1 view .LVU130
 115:../Core/Src/cwt.c ****     for(j = 0; j < J_i; j++)
 450              		.loc 1 115 5 is_stmt 0 discriminator 1 view .LVU131
 451 01b6 039B     		ldr	r3, [sp, #12]
 452 01b8 9D42     		cmp	r5, r3
 453 01ba 32D2     		bcs	.L25
 117:../Core/Src/cwt.c ****         scale_o[j] = s0_i * pow(2, (j * dj_i));
 454              		.loc 1 117 9 is_stmt 1 view .LVU132
 117:../Core/Src/cwt.c ****         scale_o[j] = s0_i * pow(2, (j * dj_i));
ARM GAS  /tmp/ccVCbso8.s 			page 15


 455              		.loc 1 117 39 is_stmt 0 view .LVU133
 456 01bc 07EE905A 		vmov	s15, r5	@ int
 457 01c0 B8EE671A 		vcvt.f32.u32	s2, s15
 458 01c4 21EE081A 		vmul.f32	s2, s2, s16
 117:../Core/Src/cwt.c ****         scale_o[j] = s0_i * pow(2, (j * dj_i));
 459              		.loc 1 117 29 view .LVU134
 460 01c8 B7EEC11A 		vcvt.f64.f32	d1, s2
 461 01cc B0EE000B 		vmov.f64	d0, #2.0e+0
 462 01d0 FFF7FEFF 		bl	pow
 463              	.LVL50:
 117:../Core/Src/cwt.c ****         scale_o[j] = s0_i * pow(2, (j * dj_i));
 464              		.loc 1 117 16 view .LVU135
 465 01d4 4FEA8509 		lsl	r9, r5, #2
 466 01d8 1A9B     		ldr	r3, [sp, #104]
 467 01da 03EB850A 		add	r10, r3, r5, lsl #2
 117:../Core/Src/cwt.c ****         scale_o[j] = s0_i * pow(2, (j * dj_i));
 468              		.loc 1 117 27 view .LVU136
 469 01de B7EEE87A 		vcvt.f64.f32	d7, s17
 470 01e2 27EE000B 		vmul.f64	d0, d7, d0
 471 01e6 B7EEC00B 		vcvt.f32.f64	s0, d0
 117:../Core/Src/cwt.c ****         scale_o[j] = s0_i * pow(2, (j * dj_i));
 472              		.loc 1 117 20 view .LVU137
 473 01ea 8AED000A 		vstr.32	s0, [r10]
 119:../Core/Src/cwt.c ****         ret = wave_bases[mother_i](wk, N_i, scale_o[j], param_i, 
 474              		.loc 1 119 9 is_stmt 1 view .LVU138
 119:../Core/Src/cwt.c ****         ret = wave_bases[mother_i](wk, N_i, scale_o[j], param_i, 
 475              		.loc 1 119 25 is_stmt 0 view .LVU139
 476 01ee 204B     		ldr	r3, .L27+48
 477 01f0 049A     		ldr	r2, [sp, #16]
 478 01f2 53F822B0 		ldr	fp, [r3, r2, lsl #2]
 119:../Core/Src/cwt.c ****         ret = wave_bases[mother_i](wk, N_i, scale_o[j], param_i, 
 479              		.loc 1 119 15 view .LVU140
 480 01f6 0DF11F03 		add	r3, sp, #31
 481 01fa 0193     		str	r3, [sp, #4]
 482 01fc 1B9B     		ldr	r3, [sp, #108]
 483 01fe 0093     		str	r3, [sp]
 484 0200 06AB     		add	r3, sp, #24
 485 0202 3A46     		mov	r2, r7
 486 0204 F0EE490A 		vmov.f32	s1, s18
 487 0208 2146     		mov	r1, r4
 488 020a 0598     		ldr	r0, [sp, #20]
 489 020c D847     		blx	fp
 490              	.LVL51:
 122:../Core/Src/cwt.c ****         if(ret)
 491              		.loc 1 122 9 is_stmt 1 view .LVU141
 122:../Core/Src/cwt.c ****         if(ret)
 492              		.loc 1 122 11 is_stmt 0 view .LVU142
 493 020e 10F0FF0F 		tst	r0, #255
 494 0212 93D1     		bne	.L26
 495              	.LBB14:
 128:../Core/Src/cwt.c ****         for(uint32_t i = 0; i < N_i; i++)
 496              		.loc 1 128 22 view .LVU143
 497 0214 0023     		movs	r3, #0
 498 0216 B9E7     		b	.L12
 499              	.L24:
 128:../Core/Src/cwt.c ****         for(uint32_t i = 0; i < N_i; i++)
 500              		.loc 1 128 22 view .LVU144
ARM GAS  /tmp/ccVCbso8.s 			page 16


 501              	.LBE14:
 138:../Core/Src/cwt.c ****             UART_puts("It was not possible to compute the inverse fourier \
 502              		.loc 1 138 13 is_stmt 1 view .LVU145
 503 0218 1648     		ldr	r0, .L27+52
 504              	.LVL52:
 138:../Core/Src/cwt.c ****             UART_puts("It was not possible to compute the inverse fourier \
 505              		.loc 1 138 13 is_stmt 0 view .LVU146
 506 021a FFF7FEFF 		bl	UART_puts
 507              	.LVL53:
 140:../Core/Src/cwt.c ****             return _EXIT_FAILURE;
 508              		.loc 1 140 13 is_stmt 1 view .LVU147
 140:../Core/Src/cwt.c ****             return _EXIT_FAILURE;
 509              		.loc 1 140 20 is_stmt 0 view .LVU148
 510 021e 0120     		movs	r0, #1
 511 0220 47E7     		b	.L1
 512              	.L25:
 147:../Core/Src/cwt.c ****     free(y_aux);
 513              		.loc 1 147 5 view .LVU149
 514 0222 DDF814B0 		ldr	fp, [sp, #20]
 147:../Core/Src/cwt.c ****     free(y_aux);
 515              		.loc 1 147 5 is_stmt 1 view .LVU150
 516 0226 0298     		ldr	r0, [sp, #8]
 517 0228 FFF7FEFF 		bl	free
 518              	.LVL54:
 149:../Core/Src/cwt.c ****     free(wk);
 519              		.loc 1 149 5 view .LVU151
 520 022c 5846     		mov	r0, fp
 521 022e FFF7FEFF 		bl	free
 522              	.LVL55:
 150:../Core/Src/cwt.c ****     free(daughter);
 523              		.loc 1 150 5 view .LVU152
 524 0232 3846     		mov	r0, r7
 525 0234 FFF7FEFF 		bl	free
 526              	.LVL56:
 152:../Core/Src/cwt.c ****     return _EXIT_SUCCESS;
 527              		.loc 1 152 5 view .LVU153
 152:../Core/Src/cwt.c ****     return _EXIT_SUCCESS;
 528              		.loc 1 152 12 is_stmt 0 view .LVU154
 529 0238 0020     		movs	r0, #0
 530 023a 3AE7     		b	.L1
 531              	.L28:
 532 023c AFF30080 		.align	3
 533              	.L27:
 534 0240 EF39FAFE 		.word	-17155601
 535 0244 422EE63F 		.word	1072049730
 536 0248 182D4454 		.word	1413754136
 537 024c FB211940 		.word	1075388923
 538 0250 00000000 		.word	0
 539 0254 00000000 		.word	0
 540 0258 00000000 		.word	.LC0
 541 025c 34000000 		.word	.LC1
 542 0260 68000000 		.word	.LC2
 543 0264 A8000000 		.word	.LC3
 544 0268 D8000000 		.word	.LC4
 545 026c 10010000 		.word	.LC5
 546 0270 00000000 		.word	wave_bases
 547 0274 44010000 		.word	.LC6
ARM GAS  /tmp/ccVCbso8.s 			page 17


 548              		.cfi_endproc
 549              	.LFE146:
 551              		.text
 552              	.Letext0:
 553              		.file 3 "../Core/Inc/complex.h"
 554              		.file 4 "/usr/lib/gcc/arm-none-eabi/10.3.1/include/stdint.h"
 555              		.file 5 "../Core/Inc/wavelet.h"
 556              		.file 6 "/usr/include/newlib/math.h"
 557              		.file 7 "../Core/Inc/fft.h"
 558              		.file 8 "/usr/include/newlib/stdlib.h"
 559              		.file 9 "../Core/Inc/usart.h"
 560              		.file 10 "<built-in>"
ARM GAS  /tmp/ccVCbso8.s 			page 18


DEFINED SYMBOLS
                            *ABS*:0000000000000000 cwt.c
     /tmp/ccVCbso8.s:17     .rodata.cwt.str1.4:0000000000000000 $d
     /tmp/ccVCbso8.s:47     .text.cwt:0000000000000000 $t
     /tmp/ccVCbso8.s:55     .text.cwt:0000000000000000 cwt
     /tmp/ccVCbso8.s:534    .text.cwt:0000000000000240 $d

UNDEFINED SYMBOLS
log
calloc
memset
fft
UART_puts
ifft
pow
free
wave_bases
