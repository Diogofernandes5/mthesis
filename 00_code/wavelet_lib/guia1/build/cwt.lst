ARM GAS  /tmp/ccTelUEZ.s 			page 1


   1              		.cpu cortex-m7
   2              		.eabi_attribute 28, 1
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 1
  11              		.eabi_attribute 18, 4
  12              		.file	"cwt.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.section	.rodata.cwt.str1.4,"aMS",%progbits,1
  17              		.align	2
  18              	.LC0:
  19 0000 54696D65 		.ascii	"Time series array length must be a power of 2!\012\015"
  19      20736572 
  19      69657320 
  19      61727261 
  19      79206C65 
  20 0030 00       		.ascii	"\000"
  21 0031 000000   		.align	2
  22              	.LC1:
  23 0034 49742077 		.ascii	"It was not possible to allocate 'y_aux' pointer!\012"
  23      6173206E 
  23      6F742070 
  23      6F737369 
  23      626C6520 
  24 0065 0D00     		.ascii	"\015\000"
  25 0067 00       		.align	2
  26              	.LC2:
  27 0068 49742077 		.ascii	"It was not possible to compute the FFT of time seri"
  27      6173206E 
  27      6F742070 
  27      6F737369 
  27      626C6520 
  28 009b 65732061 		.ascii	"es array!\012\015\000"
  28      72726179 
  28      210A0D00 
  29 00a7 00       		.align	2
  30              	.LC3:
  31 00a8 49742077 		.ascii	"It was not possible to allocate 'wk' pointer!\012\015"
  31      6173206E 
  31      6F742070 
  31      6F737369 
  31      626C6520 
  32 00d7 00       		.ascii	"\000"
  33              		.align	2
  34              	.LC4:
  35 00d8 49742077 		.ascii	"It was not possible to allocate 'daughter' pointer!"
  35      6173206E 
  35      6F742070 
  35      6F737369 
  35      626C6520 
ARM GAS  /tmp/ccTelUEZ.s 			page 2


  36 010b 0A0D00   		.ascii	"\012\015\000"
  37 010e 0000     		.align	2
  38              	.LC5:
  39 0110 49742077 		.ascii	"It was not possible to compute scales wavelet!\012\015"
  39      6173206E 
  39      6F742070 
  39      6F737369 
  39      626C6520 
  40 0140 00       		.ascii	"\000"
  41 0141 000000   		.align	2
  42              	.LC6:
  43 0144 49742077 		.ascii	"It was not possible to compute the inverse fourier "
  43      6173206E 
  43      6F742070 
  43      6F737369 
  43      626C6520 
  44 0177 20202020 		.ascii	"                transform of the tranformed signal!"
  44      20202020 
  44      20202020 
  44      20202020 
  44      7472616E 
  45 01aa 0A0D00   		.ascii	"\012\015\000"
  46              		.section	.text.cwt,"ax",%progbits
  47              		.align	1
  48              		.global	cwt
  49              		.arch armv7e-m
  50              		.syntax unified
  51              		.thumb
  52              		.thumb_func
  53              		.fpu fpv5-d16
  55              	cwt:
  56              	.LVL0:
  57              	.LFB146:
  58              		.file 1 "../Core/Src/cwt.c"
   1:../Core/Src/cwt.c **** #include "cwt.h"
   2:../Core/Src/cwt.c **** 
   3:../Core/Src/cwt.c **** #include "wavelet.h"
   4:../Core/Src/cwt.c **** #include "fft.h" 
   5:../Core/Src/cwt.c **** #include "utils.h" // is_powerof2
   6:../Core/Src/cwt.c **** 
   7:../Core/Src/cwt.c **** #include "usart.h"
   8:../Core/Src/cwt.c **** #include "errdef.h"
   9:../Core/Src/cwt.c **** 
  10:../Core/Src/cwt.c **** #include <math.h>
  11:../Core/Src/cwt.c **** #include <stdint.h>
  12:../Core/Src/cwt.c **** #include <stdlib.h> // malloc
  13:../Core/Src/cwt.c **** 
  14:../Core/Src/cwt.c **** extern int (*wave_bases[1])(float *wk_i, uint32_t N_i, float scale_i, float param_i, 
  15:../Core/Src/cwt.c ****         float *daughter_o, float *fourier_factor_o, float *coi_o, uint8_t *dof_min_o);
  16:../Core/Src/cwt.c ****         // = {morlet_base}; //, null, null}; // morlet, paul, DOG
  17:../Core/Src/cwt.c **** 
  18:../Core/Src/cwt.c **** /**
  19:../Core/Src/cwt.c ****  * @brief   Computes the wavelet transform of the vector y_i (length N_i),
  20:../Core/Src/cwt.c ****  *              with sampling rate dt_i.
  21:../Core/Src/cwt.c ****  * 
  22:../Core/Src/cwt.c ****  * @param   y_i         - time series array to be computed (size N_i)
  23:../Core/Src/cwt.c ****  * @param   N_i         - time series array length (must be a power of 2)
ARM GAS  /tmp/ccTelUEZ.s 			page 3


  24:../Core/Src/cwt.c ****  * @param   dt_i        - sampling period
  25:../Core/Src/cwt.c ****  * @param   dj_i        - spacing between scales 
  26:../Core/Src/cwt.c ****  * @param   s0_i        - smallest scale of the wavelet
  27:../Core/Src/cwt.c ****  * @param   J_i         - total number of scales (range = [s0_i, s0_i*2^(J_i*dj_i)])
  28:../Core/Src/cwt.c ****  * @param   mother_i    - mother wavelet (morlet, paul, dog)
  29:../Core/Src/cwt.c ****  * @param   param_i     - mother wavelet parameter
  30:../Core/Src/cwt.c ****  * 
  31:../Core/Src/cwt.c ****  * @param   y_cwt_o     - cwt applied in complex array with size (J_i x N_i)
  32:../Core/Src/cwt.c ****  * @param   period_o    - array of Fourier periods (in time units) 
  33:../Core/Src/cwt.c ****  *                            that corresponds to the scales
  34:../Core/Src/cwt.c ****  * @param   scale_o     - array of scale indices, given by s0_i*2^(j*dj_i),
  35:../Core/Src/cwt.c ****  *                            j = 0...J_i
  36:../Core/Src/cwt.c ****  * @param   coi_o       - array of N_i points containing the max period of useful
  37:../Core/Src/cwt.c ****  *                            information
  38:../Core/Src/cwt.c ****  * 
  39:../Core/Src/cwt.c ****  * @retval  Success
  40:../Core/Src/cwt.c ****  * */
  41:../Core/Src/cwt.c **** int cwt(complex *y_i, uint32_t N_i, float dt_i, float dj_i, float s0_i, uint32_t J_i, 
  42:../Core/Src/cwt.c ****             wavelet_funcs mother_i, float param_i,
  43:../Core/Src/cwt.c ****             complex *y_cwt_o, float *period_o, float *scale_o, float *coi_o)
  44:../Core/Src/cwt.c **** {
  59              		.loc 1 44 1 view -0
  60              		.cfi_startproc
  61              		@ args = 16, pretend = 0, frame = 24
  62              		@ frame_needed = 0, uses_anonymous_args = 0
  63              		.loc 1 44 1 is_stmt 0 view .LVU1
  64 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
  65              	.LCFI0:
  66              		.cfi_def_cfa_offset 36
  67              		.cfi_offset 4, -36
  68              		.cfi_offset 5, -32
  69              		.cfi_offset 6, -28
  70              		.cfi_offset 7, -24
  71              		.cfi_offset 8, -20
  72              		.cfi_offset 9, -16
  73              		.cfi_offset 10, -12
  74              		.cfi_offset 11, -8
  75              		.cfi_offset 14, -4
  76 0004 2DED068B 		vpush.64	{d8, d9, d10}
  77              	.LCFI1:
  78              		.cfi_def_cfa_offset 60
  79              		.cfi_offset 80, -60
  80              		.cfi_offset 81, -56
  81              		.cfi_offset 82, -52
  82              		.cfi_offset 83, -48
  83              		.cfi_offset 84, -44
  84              		.cfi_offset 85, -40
  85 0008 89B0     		sub	sp, sp, #36
  86              	.LCFI2:
  87              		.cfi_def_cfa_offset 96
  88 000a 0746     		mov	r7, r0
  89 000c 0C46     		mov	r4, r1
  90 000e B0EE40AA 		vmov.f32	s20, s0
  91 0012 B0EE608A 		vmov.f32	s16, s1
  92 0016 F0EE418A 		vmov.f32	s17, s2
  93 001a 0592     		str	r2, [sp, #20]
  94 001c 0793     		str	r3, [sp, #28]
ARM GAS  /tmp/ccTelUEZ.s 			page 4


  95 001e B0EE619A 		vmov.f32	s18, s3
  96 0022 189D     		ldr	r5, [sp, #96]
  45:../Core/Src/cwt.c ****     uint8_t ret = 0;
  97              		.loc 1 45 5 is_stmt 1 view .LVU2
  98              	.LVL1:
  46:../Core/Src/cwt.c ****     uint32_t k; /* iterator */
  99              		.loc 1 46 5 view .LVU3
  47:../Core/Src/cwt.c ****     uint32_t j;
 100              		.loc 1 47 5 view .LVU4
  48:../Core/Src/cwt.c ****     uint8_t *dof_min = (uint8_t*) malloc(sizeof(uint8_t));
 101              		.loc 1 48 5 view .LVU5
 102              		.loc 1 48 35 is_stmt 0 view .LVU6
 103 0024 0120     		movs	r0, #1
 104              	.LVL2:
 105              		.loc 1 48 35 view .LVU7
 106 0026 FFF7FEFF 		bl	malloc
 107              	.LVL3:
 108              		.loc 1 48 35 view .LVU8
 109 002a 0490     		str	r0, [sp, #16]
 110              	.LVL4:
  49:../Core/Src/cwt.c ****     float *fourier_factor = (float*) malloc(sizeof(float));
 111              		.loc 1 49 5 is_stmt 1 view .LVU9
 112              		.loc 1 49 38 is_stmt 0 view .LVU10
 113 002c 0420     		movs	r0, #4
 114              	.LVL5:
 115              		.loc 1 49 38 view .LVU11
 116 002e FFF7FEFF 		bl	malloc
 117              	.LVL6:
 118 0032 8346     		mov	fp, r0
 119              	.LVL7:
  50:../Core/Src/cwt.c **** 
  51:../Core/Src/cwt.c **** 	// verify power of 2 length
  52:../Core/Src/cwt.c **** 	if(!is_powerof2((float) N_i))
 120              		.loc 1 52 2 is_stmt 1 view .LVU12
 121              		.loc 1 52 18 is_stmt 0 view .LVU13
 122 0034 07EE904A 		vmov	s15, r4	@ int
 123 0038 F8EE679A 		vcvt.f32.u32	s19, s15
 124              		.loc 1 52 6 view .LVU14
 125 003c BDEEE90A 		vcvt.s32.f32	s0, s19
 126              	.LVL8:
 127              	.LBB9:
 128              	.LBI9:
 129              		.file 2 "../Core/Inc/utils.h"
   1:../Core/Inc/utils.h **** /**
   2:../Core/Inc/utils.h ****  * @file   	utils.h
   3:../Core/Inc/utils.h ****  * @author 	Diogo Fernandes (diogo.cf20@gmail.com)
   4:../Core/Inc/utils.h ****  * */
   5:../Core/Inc/utils.h **** 
   6:../Core/Inc/utils.h **** #ifndef _UTILS_H_
   7:../Core/Inc/utils.h **** #define _UTILS_H_
   8:../Core/Inc/utils.h **** 
   9:../Core/Inc/utils.h **** #ifdef __cplusplus
  10:../Core/Inc/utils.h **** extern "C" {
  11:../Core/Inc/utils.h **** #endif
  12:../Core/Inc/utils.h **** 
  13:../Core/Inc/utils.h **** #include <stdint.h>
  14:../Core/Inc/utils.h **** #include <math.h> // -lm flag necessary
ARM GAS  /tmp/ccTelUEZ.s 			page 5


  15:../Core/Inc/utils.h **** 
  16:../Core/Inc/utils.h **** /******************************************************************************
  17:../Core/Inc/utils.h **** Defines and Macros
  18:../Core/Inc/utils.h **** ******************************************************************************/
  19:../Core/Inc/utils.h **** 
  20:../Core/Inc/utils.h **** #define IS_ADDR16(__addr16__)           ((uint32_t)(__addr16__) < 0x10000) // Valid for [0 - 0xFFFF
  21:../Core/Inc/utils.h **** #define IS_ADDR8(__addr8__)                 ((uint16_t)(__addr8__) < 0x100) // Valid for [0 - 0xFF]
  22:../Core/Inc/utils.h **** #define IS_ADDR4(__addr4__)                 ((uint8_t)(__addr4__) < 0x10)   // Valid for [0 - 0x0F]
  23:../Core/Inc/utils.h **** 
  24:../Core/Inc/utils.h **** #define IS_BIT_SET(_byte_, _nbit_)  (((_byte_)>>(_nbit_)) & 0x01)
  25:../Core/Inc/utils.h **** #define CLEARBIT(_byte_, _nbit_)        ((_byte_) &= ~(1<<(_nbit_)))
  26:../Core/Inc/utils.h **** //#define setbit(x,n)   x|=(1<<n)
  27:../Core/Inc/utils.h **** //#define togglebit(x,n)  x^=(1<<n)
  28:../Core/Inc/utils.h **** //#define isbitclear(x,n) !((x>>n) & 0x1)
  29:../Core/Inc/utils.h **** 
  30:../Core/Inc/utils.h **** #define IS_PRINTABLE(__ch__)    (((__ch__) > 0x1F) && ((__ch__) < 0x7F)) // Is true if __ch__ is a 
  31:../Core/Inc/utils.h **** 
  32:../Core/Inc/utils.h **** #define IS_DIG(__dig__)                         (((uint8_t)(__dig__) > 0x00) && ((uint8_t)(__dig__)
  33:../Core/Inc/utils.h **** 
  34:../Core/Inc/utils.h **** //typedef enum comm_operation {write = 0, read};
  35:../Core/Inc/utils.h **** 
  36:../Core/Inc/utils.h **** /******************************************************************************
  37:../Core/Inc/utils.h **** Function Prototypes
  38:../Core/Inc/utils.h **** ******************************************************************************/
  39:../Core/Inc/utils.h **** 
  40:../Core/Inc/utils.h **** int my_atoi(const char *str);
  41:../Core/Inc/utils.h **** 
  42:../Core/Inc/utils.h **** /******************************************************************************
  43:../Core/Inc/utils.h **** Function Definition
  44:../Core/Inc/utils.h **** ******************************************************************************/
  45:../Core/Inc/utils.h **** 
  46:../Core/Inc/utils.h **** /**
  47:../Core/Inc/utils.h ****  * @brief   Verifies if val is integer
  48:../Core/Inc/utils.h ****  * 
  49:../Core/Inc/utils.h ****  * @param   val -number to verify
  50:../Core/Inc/utils.h ****  * 
  51:../Core/Inc/utils.h ****  * @retval  yes (1) / no (0) 
  52:../Core/Inc/utils.h ****  * */
  53:../Core/Inc/utils.h **** static inline uint8_t isInteger(double val)
  54:../Core/Inc/utils.h **** {
  55:../Core/Inc/utils.h ****     int truncated = (int)val;
  56:../Core/Inc/utils.h ****     return (val == truncated);
  57:../Core/Inc/utils.h **** }
  58:../Core/Inc/utils.h **** 
  59:../Core/Inc/utils.h **** /**
  60:../Core/Inc/utils.h ****  * @brief   Verifies if n is power of 2 number
  61:../Core/Inc/utils.h ****  * 
  62:../Core/Inc/utils.h ****  * @param   n - number to verify
  63:../Core/Inc/utils.h ****  * 
  64:../Core/Inc/utils.h ****  * @retval  yes (1) / no (0) 
  65:../Core/Inc/utils.h ****  * */
  66:../Core/Inc/utils.h **** static inline uint8_t is_powerof2(int n)
 130              		.loc 2 66 23 is_stmt 1 view .LVU15
 131              	.LBB10:
  67:../Core/Inc/utils.h **** {
  68:../Core/Inc/utils.h ****     double log_n = (log(n)/log(2));
 132              		.loc 2 68 5 view .LVU16
ARM GAS  /tmp/ccTelUEZ.s 			page 6


 133              		.loc 2 68 21 is_stmt 0 view .LVU17
 134 0040 B8EEC00B 		vcvt.f64.s32	d0, s0
 135              	.LVL9:
 136              		.loc 2 68 21 view .LVU18
 137 0044 FFF7FEFF 		bl	log
 138              	.LVL10:
 139              		.loc 2 68 12 view .LVU19
 140 0048 9FED777B 		vldr.64	d7, .L25
 141 004c 80EE076B 		vdiv.f64	d6, d0, d7
 142              	.LVL11:
  69:../Core/Inc/utils.h ****     return isInteger(log_n);
 143              		.loc 2 69 5 is_stmt 1 view .LVU20
 144              	.LBB11:
 145              	.LBI11:
  53:../Core/Inc/utils.h **** {
 146              		.loc 2 53 23 view .LVU21
 147              	.LBB12:
  55:../Core/Inc/utils.h ****     return (val == truncated);
 148              		.loc 2 55 5 view .LVU22
  55:../Core/Inc/utils.h ****     return (val == truncated);
 149              		.loc 2 55 9 is_stmt 0 view .LVU23
 150 0050 BDEEC67B 		vcvt.s32.f64	s14, d6
 151              	.LVL12:
  56:../Core/Inc/utils.h **** }
 152              		.loc 2 56 5 is_stmt 1 view .LVU24
  56:../Core/Inc/utils.h **** }
 153              		.loc 2 56 17 is_stmt 0 view .LVU25
 154 0054 B8EEC77B 		vcvt.f64.s32	d7, s14
 155              	.LVL13:
  56:../Core/Inc/utils.h **** }
 156              		.loc 2 56 17 view .LVU26
 157              	.LBE12:
 158              	.LBE11:
 159              	.LBE10:
 160              	.LBE9:
 161              		.loc 1 52 4 view .LVU27
 162 0058 B4EE467B 		vcmp.f64	d7, d6
 163 005c F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 164 0060 20D1     		bne	.L17
  53:../Core/Src/cwt.c **** 	{
  54:../Core/Src/cwt.c **** 		// or you can pad the array with zeros until the neareast greater power of 2
  55:../Core/Src/cwt.c ****         // this will increase the frequency resolution 
  56:../Core/Src/cwt.c **** 		UART_puts("Time series array length must be a power of 2!\n\r");
  57:../Core/Src/cwt.c **** 		return _EXIT_FAILURE;
  58:../Core/Src/cwt.c **** 	}
  59:../Core/Src/cwt.c **** 
  60:../Core/Src/cwt.c ****     uint16_t half_N_i = (uint16_t) N_i >> 1; /* half lenght of the time 
 165              		.loc 1 60 5 is_stmt 1 view .LVU28
 166              		.loc 1 60 14 is_stmt 0 view .LVU29
 167 0062 C4F34E06 		ubfx	r6, r4, #1, #15
 168              	.LVL14:
  61:../Core/Src/cwt.c ****                                                     series array */
  62:../Core/Src/cwt.c ****     
  63:../Core/Src/cwt.c ****     /* Compute FFT of time series array - Equation 3 */
  64:../Core/Src/cwt.c ****     complex *y_aux = (complex *) calloc(N_i, sizeof(complex)); /* auxliary empty array */
 169              		.loc 1 64 5 is_stmt 1 view .LVU30
 170              		.loc 1 64 34 is_stmt 0 view .LVU31
ARM GAS  /tmp/ccTelUEZ.s 			page 7


 171 0066 0821     		movs	r1, #8
 172 0068 2046     		mov	r0, r4
 173 006a FFF7FEFF 		bl	calloc
 174              	.LVL15:
  65:../Core/Src/cwt.c ****     if(y_aux == NULL)
 175              		.loc 1 65 5 is_stmt 1 view .LVU32
 176              		.loc 1 65 7 is_stmt 0 view .LVU33
 177 006e 0390     		str	r0, [sp, #12]
 178 0070 08B3     		cbz	r0, .L18
  66:../Core/Src/cwt.c ****     {
  67:../Core/Src/cwt.c ****         UART_puts("It was not possible to allocate 'y_aux' pointer!\n\r");
  68:../Core/Src/cwt.c ****         return -ENOMEM;
  69:../Core/Src/cwt.c ****     }
  70:../Core/Src/cwt.c **** 
  71:../Core/Src/cwt.c ****     ret = fft(y_i, N_i, y_aux);
 179              		.loc 1 71 5 is_stmt 1 view .LVU34
 180              		.loc 1 71 11 is_stmt 0 view .LVU35
 181 0072 039A     		ldr	r2, [sp, #12]
 182 0074 2146     		mov	r1, r4
 183 0076 3846     		mov	r0, r7
 184              	.LVL16:
 185              		.loc 1 71 11 view .LVU36
 186 0078 FFF7FEFF 		bl	fft
 187              	.LVL17:
  72:../Core/Src/cwt.c ****     if(ret)
 188              		.loc 1 72 5 is_stmt 1 view .LVU37
 189              		.loc 1 72 7 is_stmt 0 view .LVU38
 190 007c 08BB     		cbnz	r0, .L19
  73:../Core/Src/cwt.c ****     {
  74:../Core/Src/cwt.c ****         UART_puts("It was not possible to compute the FFT of time series array!\n\r");
  75:../Core/Src/cwt.c ****         return _EXIT_FAILURE;
  76:../Core/Src/cwt.c ****     }
  77:../Core/Src/cwt.c **** 
  78:../Core/Src/cwt.c ****     /* Construct wavenumber array used in transform - Equation 5 */
  79:../Core/Src/cwt.c ****     /* NOTE: in Torrence's matlab code this is done in another way
  80:../Core/Src/cwt.c ****         where after half array, the wk is descending */
  81:../Core/Src/cwt.c ****     float *wk = (float*) calloc(N_i, sizeof(float));
 191              		.loc 1 81 5 is_stmt 1 view .LVU39
 192              		.loc 1 81 26 is_stmt 0 view .LVU40
 193 007e 0421     		movs	r1, #4
 194 0080 2046     		mov	r0, r4
 195              	.LVL18:
 196              		.loc 1 81 26 view .LVU41
 197 0082 FFF7FEFF 		bl	calloc
 198              	.LVL19:
  82:../Core/Src/cwt.c ****     if(wk == NULL)
 199              		.loc 1 82 5 is_stmt 1 view .LVU42
 200              		.loc 1 82 7 is_stmt 0 view .LVU43
 201 0086 0690     		str	r0, [sp, #24]
 202 0088 00B3     		cbz	r0, .L20
  83:../Core/Src/cwt.c ****     {
  84:../Core/Src/cwt.c ****         UART_puts("It was not possible to allocate 'wk' pointer!\n\r");
  85:../Core/Src/cwt.c ****         return -ENOMEM;
  86:../Core/Src/cwt.c ****     }
  87:../Core/Src/cwt.c **** 
  88:../Core/Src/cwt.c ****     float multiplier_aux = (2 * M_PI) / (N_i * dt_i);
 203              		.loc 1 88 5 is_stmt 1 view .LVU44
ARM GAS  /tmp/ccTelUEZ.s 			page 8


 204              		.loc 1 88 46 is_stmt 0 view .LVU45
 205 008a 29EE8A6A 		vmul.f32	s12, s19, s20
 206 008e B7EEC66A 		vcvt.f64.f32	d6, s12
 207              		.loc 1 88 39 view .LVU46
 208 0092 9FED675B 		vldr.64	d5, .L25+8
 209 0096 85EE067B 		vdiv.f64	d7, d5, d6
 210              		.loc 1 88 11 view .LVU47
 211 009a B7EEC77B 		vcvt.f32.f64	s14, d7
 212              	.LVL20:
  89:../Core/Src/cwt.c **** 
  90:../Core/Src/cwt.c ****     /* k <= N/2 */
  91:../Core/Src/cwt.c ****     for(k = 0; k < (half_N_i + 1); k++)
 213              		.loc 1 91 5 is_stmt 1 view .LVU48
 214              		.loc 1 91 11 is_stmt 0 view .LVU49
 215 009e 0023     		movs	r3, #0
 216 00a0 0699     		ldr	r1, [sp, #24]
 217              		.loc 1 91 5 view .LVU50
 218 00a2 24E0     		b	.L7
 219              	.LVL21:
 220              	.L17:
  56:../Core/Src/cwt.c **** 		return _EXIT_FAILURE;
 221              		.loc 1 56 3 is_stmt 1 view .LVU51
 222 00a4 6448     		ldr	r0, .L25+16
 223 00a6 FFF7FEFF 		bl	UART_puts
 224              	.LVL22:
  57:../Core/Src/cwt.c **** 	}
 225              		.loc 1 57 3 view .LVU52
  57:../Core/Src/cwt.c **** 	}
 226              		.loc 1 57 10 is_stmt 0 view .LVU53
 227 00aa 0120     		movs	r0, #1
 228              	.LVL23:
 229              	.L1:
  92:../Core/Src/cwt.c ****     {
  93:../Core/Src/cwt.c ****         wk[k] = multiplier_aux * k;
  94:../Core/Src/cwt.c ****     }
  95:../Core/Src/cwt.c **** 
  96:../Core/Src/cwt.c ****     /* k > N/2 */
  97:../Core/Src/cwt.c ****     // for(k = half_N_i; k <= N_i; k++)
  98:../Core/Src/cwt.c ****     // {
  99:../Core/Src/cwt.c ****     //     wk[k] = - multiplier_aux * k;
 100:../Core/Src/cwt.c ****     // }
 101:../Core/Src/cwt.c **** 
 102:../Core/Src/cwt.c ****     float *daughter = (float*) calloc(N_i, sizeof(float));
 103:../Core/Src/cwt.c ****     if(daughter == NULL)
 104:../Core/Src/cwt.c ****     {
 105:../Core/Src/cwt.c ****         UART_puts("It was not possible to allocate 'daughter' pointer!\n\r");
 106:../Core/Src/cwt.c ****         return -ENOMEM;
 107:../Core/Src/cwt.c ****     }
 108:../Core/Src/cwt.c **** 
 109:../Core/Src/cwt.c ****     /* Loop through scales */
 110:../Core/Src/cwt.c ****     for(j = 0; j < (J_i + 1); j++)
 111:../Core/Src/cwt.c ****     {
 112:../Core/Src/cwt.c ****         scale_o[j] = s0_i * pow(2, (j * dj_i));
 113:../Core/Src/cwt.c **** 
 114:../Core/Src/cwt.c ****         ret = wave_bases[mother_i](wk, N_i, scale_o[j], param_i, 
 115:../Core/Src/cwt.c ****             daughter, fourier_factor, coi_o, dof_min);
 116:../Core/Src/cwt.c **** 
ARM GAS  /tmp/ccTelUEZ.s 			page 9


 117:../Core/Src/cwt.c ****         if(ret)
 118:../Core/Src/cwt.c ****         {
 119:../Core/Src/cwt.c ****             UART_puts("It was not possible to compute scales wavelet!\n\r");
 120:../Core/Src/cwt.c ****             return _EXIT_FAILURE;
 121:../Core/Src/cwt.c ****         }
 122:../Core/Src/cwt.c **** 
 123:../Core/Src/cwt.c ****         for(uint32_t i = 0; i < (N_i + 1); i++)
 124:../Core/Src/cwt.c ****         {
 125:../Core/Src/cwt.c ****             y_cwt_o[i].Re = complex_mul_re(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 126:../Core/Src/cwt.c ****             y_cwt_o[i].Im = complex_mul_im(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 127:../Core/Src/cwt.c ****         }
 128:../Core/Src/cwt.c **** 
 129:../Core/Src/cwt.c ****         ret = ifft(y_cwt_o, N_i, y_aux);
 130:../Core/Src/cwt.c **** 
 131:../Core/Src/cwt.c ****         if(ret)
 132:../Core/Src/cwt.c ****         {
 133:../Core/Src/cwt.c ****             UART_puts("It was not possible to compute the inverse fourier \
 134:../Core/Src/cwt.c ****                 transform of the tranformed signal!\n\r");
 135:../Core/Src/cwt.c ****             return _EXIT_FAILURE;
 136:../Core/Src/cwt.c ****         }
 137:../Core/Src/cwt.c **** 
 138:../Core/Src/cwt.c ****         period_o[j] = (*fourier_factor) * scale_o[j];
 139:../Core/Src/cwt.c ****     }
 140:../Core/Src/cwt.c **** 
 141:../Core/Src/cwt.c ****     /* Liberate memory space */
 142:../Core/Src/cwt.c ****     free(y_aux);
 143:../Core/Src/cwt.c **** 
 144:../Core/Src/cwt.c ****     free(dof_min);
 145:../Core/Src/cwt.c ****     free(fourier_factor);
 146:../Core/Src/cwt.c **** 
 147:../Core/Src/cwt.c ****     free(wk);
 148:../Core/Src/cwt.c ****     free(daughter);
 149:../Core/Src/cwt.c **** 
 150:../Core/Src/cwt.c ****     return _EXIT_SUCCESS;
 151:../Core/Src/cwt.c **** }...
 230              		.loc 1 151 1 view .LVU54
 231 00ac 09B0     		add	sp, sp, #36
 232              	.LCFI3:
 233              		.cfi_remember_state
 234              		.cfi_def_cfa_offset 60
 235              		@ sp needed
 236 00ae BDEC068B 		vldm	sp!, {d8-d10}
 237              	.LCFI4:
 238              		.cfi_restore 84
 239              		.cfi_restore 85
 240              		.cfi_restore 82
 241              		.cfi_restore 83
 242              		.cfi_restore 80
 243              		.cfi_restore 81
 244              		.cfi_def_cfa_offset 36
 245              	.LVL24:
 246              		.loc 1 151 1 view .LVU55
 247 00b2 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 248              	.LVL25:
 249              	.L18:
 250              	.LCFI5:
 251              		.cfi_restore_state
ARM GAS  /tmp/ccTelUEZ.s 			page 10


  67:../Core/Src/cwt.c ****         UART_puts("It was not possible to allocate 'y_aux' pointer!\n\r");
 252              		.loc 1 67 9 is_stmt 1 view .LVU56
 253 00b6 6148     		ldr	r0, .L25+20
 254              	.LVL26:
  67:../Core/Src/cwt.c ****         UART_puts("It was not possible to allocate 'y_aux' pointer!\n\r");
 255              		.loc 1 67 9 is_stmt 0 view .LVU57
 256 00b8 FFF7FEFF 		bl	UART_puts
 257              	.LVL27:
  68:../Core/Src/cwt.c ****         return -ENOMEM;
 258              		.loc 1 68 9 is_stmt 1 view .LVU58
  68:../Core/Src/cwt.c ****         return -ENOMEM;
 259              		.loc 1 68 16 is_stmt 0 view .LVU59
 260 00bc 6FF00400 		mvn	r0, #4
 261 00c0 F4E7     		b	.L1
 262              	.LVL28:
 263              	.L19:
  74:../Core/Src/cwt.c ****         UART_puts("It was not possible to compute the FFT of time series array!\n\r");
 264              		.loc 1 74 9 is_stmt 1 view .LVU60
 265 00c2 5F48     		ldr	r0, .L25+24
 266              	.LVL29:
  74:../Core/Src/cwt.c ****         UART_puts("It was not possible to compute the FFT of time series array!\n\r");
 267              		.loc 1 74 9 is_stmt 0 view .LVU61
 268 00c4 FFF7FEFF 		bl	UART_puts
 269              	.LVL30:
  75:../Core/Src/cwt.c ****         return _EXIT_FAILURE;
 270              		.loc 1 75 9 is_stmt 1 view .LVU62
  75:../Core/Src/cwt.c ****         return _EXIT_FAILURE;
 271              		.loc 1 75 16 is_stmt 0 view .LVU63
 272 00c8 0120     		movs	r0, #1
 273 00ca EFE7     		b	.L1
 274              	.LVL31:
 275              	.L20:
  84:../Core/Src/cwt.c ****         UART_puts("It was not possible to allocate 'wk' pointer!\n\r");
 276              		.loc 1 84 9 is_stmt 1 view .LVU64
 277 00cc 5D48     		ldr	r0, .L25+28
 278              	.LVL32:
  84:../Core/Src/cwt.c ****         UART_puts("It was not possible to allocate 'wk' pointer!\n\r");
 279              		.loc 1 84 9 is_stmt 0 view .LVU65
 280 00ce FFF7FEFF 		bl	UART_puts
 281              	.LVL33:
  85:../Core/Src/cwt.c ****         return -ENOMEM;
 282              		.loc 1 85 9 is_stmt 1 view .LVU66
  85:../Core/Src/cwt.c ****         return -ENOMEM;
 283              		.loc 1 85 16 is_stmt 0 view .LVU67
 284 00d2 6FF00400 		mvn	r0, #4
 285 00d6 E9E7     		b	.L1
 286              	.LVL34:
 287              	.L8:
  93:../Core/Src/cwt.c ****         wk[k] = multiplier_aux * k;
 288              		.loc 1 93 9 is_stmt 1 discriminator 3 view .LVU68
  93:../Core/Src/cwt.c ****         wk[k] = multiplier_aux * k;
 289              		.loc 1 93 11 is_stmt 0 discriminator 3 view .LVU69
 290 00d8 01EB8302 		add	r2, r1, r3, lsl #2
  93:../Core/Src/cwt.c ****         wk[k] = multiplier_aux * k;
 291              		.loc 1 93 32 discriminator 3 view .LVU70
 292 00dc 07EE903A 		vmov	s15, r3	@ int
 293 00e0 F8EE677A 		vcvt.f32.u32	s15, s15
ARM GAS  /tmp/ccTelUEZ.s 			page 11


 294 00e4 67EE877A 		vmul.f32	s15, s15, s14
  93:../Core/Src/cwt.c ****         wk[k] = multiplier_aux * k;
 295              		.loc 1 93 15 discriminator 3 view .LVU71
 296 00e8 C2ED007A 		vstr.32	s15, [r2]
  91:../Core/Src/cwt.c ****     for(k = 0; k < (half_N_i + 1); k++)
 297              		.loc 1 91 36 is_stmt 1 discriminator 3 view .LVU72
  91:../Core/Src/cwt.c ****     for(k = 0; k < (half_N_i + 1); k++)
 298              		.loc 1 91 37 is_stmt 0 discriminator 3 view .LVU73
 299 00ec 0133     		adds	r3, r3, #1
 300              	.LVL35:
 301              	.L7:
  91:../Core/Src/cwt.c ****     for(k = 0; k < (half_N_i + 1); k++)
 302              		.loc 1 91 16 is_stmt 1 discriminator 1 view .LVU74
  91:../Core/Src/cwt.c ****     for(k = 0; k < (half_N_i + 1); k++)
 303              		.loc 1 91 30 is_stmt 0 discriminator 1 view .LVU75
 304 00ee 721C     		adds	r2, r6, #1
  91:../Core/Src/cwt.c ****     for(k = 0; k < (half_N_i + 1); k++)
 305              		.loc 1 91 5 discriminator 1 view .LVU76
 306 00f0 9A42     		cmp	r2, r3
 307 00f2 F1D8     		bhi	.L8
 102:../Core/Src/cwt.c ****     float *daughter = (float*) calloc(N_i, sizeof(float));
 308              		.loc 1 102 5 is_stmt 1 view .LVU77
 102:../Core/Src/cwt.c ****     float *daughter = (float*) calloc(N_i, sizeof(float));
 309              		.loc 1 102 32 is_stmt 0 view .LVU78
 310 00f4 0421     		movs	r1, #4
 311 00f6 2046     		mov	r0, r4
 312              	.LVL36:
 102:../Core/Src/cwt.c ****     float *daughter = (float*) calloc(N_i, sizeof(float));
 313              		.loc 1 102 32 view .LVU79
 314 00f8 FFF7FEFF 		bl	calloc
 315              	.LVL37:
 103:../Core/Src/cwt.c ****     if(daughter == NULL)
 316              		.loc 1 103 5 is_stmt 1 view .LVU80
 103:../Core/Src/cwt.c ****     if(daughter == NULL)
 317              		.loc 1 103 7 is_stmt 0 view .LVU81
 318 00fc 0646     		mov	r6, r0
 319              	.LVL38:
 103:../Core/Src/cwt.c ****     if(daughter == NULL)
 320              		.loc 1 103 7 view .LVU82
 321 00fe 18B1     		cbz	r0, .L21
 110:../Core/Src/cwt.c ****     for(j = 0; j < (J_i + 1); j++)
 322              		.loc 1 110 11 view .LVU83
 323 0100 4FF00008 		mov	r8, #0
 324 0104 0297     		str	r7, [sp, #8]
 325 0106 44E0     		b	.L9
 326              	.L21:
 105:../Core/Src/cwt.c ****         UART_puts("It was not possible to allocate 'daughter' pointer!\n\r");
 327              		.loc 1 105 9 is_stmt 1 view .LVU84
 328 0108 4F48     		ldr	r0, .L25+32
 329              	.LVL39:
 105:../Core/Src/cwt.c ****         UART_puts("It was not possible to allocate 'daughter' pointer!\n\r");
 330              		.loc 1 105 9 is_stmt 0 view .LVU85
 331 010a FFF7FEFF 		bl	UART_puts
 332              	.LVL40:
 106:../Core/Src/cwt.c ****         return -ENOMEM;
 333              		.loc 1 106 9 is_stmt 1 view .LVU86
 106:../Core/Src/cwt.c ****         return -ENOMEM;
ARM GAS  /tmp/ccTelUEZ.s 			page 12


 334              		.loc 1 106 16 is_stmt 0 view .LVU87
 335 010e 6FF00400 		mvn	r0, #4
 336 0112 CBE7     		b	.L1
 337              	.LVL41:
 338              	.L24:
 119:../Core/Src/cwt.c ****             UART_puts("It was not possible to compute scales wavelet!\n\r");
 339              		.loc 1 119 13 is_stmt 1 view .LVU88
 340 0114 4D48     		ldr	r0, .L25+36
 341              	.LVL42:
 119:../Core/Src/cwt.c ****             UART_puts("It was not possible to compute scales wavelet!\n\r");
 342              		.loc 1 119 13 is_stmt 0 view .LVU89
 343 0116 FFF7FEFF 		bl	UART_puts
 344              	.LVL43:
 120:../Core/Src/cwt.c ****             return _EXIT_FAILURE;
 345              		.loc 1 120 13 is_stmt 1 view .LVU90
 120:../Core/Src/cwt.c ****             return _EXIT_FAILURE;
 346              		.loc 1 120 20 is_stmt 0 view .LVU91
 347 011a 0120     		movs	r0, #1
 348 011c C6E7     		b	.L1
 349              	.LVL44:
 350              	.L11:
 351              	.LBB13:
 125:../Core/Src/cwt.c ****             y_cwt_o[i].Re = complex_mul_re(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 352              		.loc 1 125 13 is_stmt 1 discriminator 3 view .LVU92
 125:../Core/Src/cwt.c ****             y_cwt_o[i].Re = complex_mul_re(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 353              		.loc 1 125 29 is_stmt 0 discriminator 3 view .LVU93
 354 011e 07EBC302 		add	r2, r7, r3, lsl #3
 355 0122 92ED007A 		vldr.32	s14, [r2]
 356 0126 06EB8301 		add	r1, r6, r3, lsl #2
 357 012a 91ED006A 		vldr.32	s12, [r1]
 358 012e 27EE067A 		vmul.f32	s14, s14, s12
 359 0132 D2ED016A 		vldr.32	s13, [r2, #4]
 360 0136 DFED465A 		vldr.32	s11, .L25+40
 361 013a 66EEA56A 		vmul.f32	s13, s13, s11
 125:../Core/Src/cwt.c ****             y_cwt_o[i].Re = complex_mul_re(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 362              		.loc 1 125 20 discriminator 3 view .LVU94
 363 013e 05EBC301 		add	r1, r5, r3, lsl #3
 125:../Core/Src/cwt.c ****             y_cwt_o[i].Re = complex_mul_re(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 364              		.loc 1 125 29 discriminator 3 view .LVU95
 365 0142 37EE667A 		vsub.f32	s14, s14, s13
 125:../Core/Src/cwt.c ****             y_cwt_o[i].Re = complex_mul_re(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 366              		.loc 1 125 27 discriminator 3 view .LVU96
 367 0146 81ED007A 		vstr.32	s14, [r1]
 126:../Core/Src/cwt.c ****             y_cwt_o[i].Im = complex_mul_im(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 368              		.loc 1 126 13 is_stmt 1 discriminator 3 view .LVU97
 126:../Core/Src/cwt.c ****             y_cwt_o[i].Im = complex_mul_im(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 369              		.loc 1 126 29 is_stmt 0 discriminator 3 view .LVU98
 370 014a D2ED007A 		vldr.32	s15, [r2]
 371 014e 67EEA57A 		vmul.f32	s15, s15, s11
 372 0152 92ED017A 		vldr.32	s14, [r2, #4]
 373 0156 27EE067A 		vmul.f32	s14, s14, s12
 374 015a 77EE877A 		vadd.f32	s15, s15, s14
 126:../Core/Src/cwt.c ****             y_cwt_o[i].Im = complex_mul_im(y_i[i].Re, y_i[i].Im, daughter[i], 0);
 375              		.loc 1 126 27 discriminator 3 view .LVU99
 376 015e C1ED017A 		vstr.32	s15, [r1, #4]
 123:../Core/Src/cwt.c ****         for(uint32_t i = 0; i < (N_i + 1); i++)
 377              		.loc 1 123 44 is_stmt 1 discriminator 3 view .LVU100
ARM GAS  /tmp/ccTelUEZ.s 			page 13


 123:../Core/Src/cwt.c ****         for(uint32_t i = 0; i < (N_i + 1); i++)
 378              		.loc 1 123 45 is_stmt 0 discriminator 3 view .LVU101
 379 0162 0133     		adds	r3, r3, #1
 380              	.LVL45:
 381              	.L10:
 123:../Core/Src/cwt.c ****         for(uint32_t i = 0; i < (N_i + 1); i++)
 382              		.loc 1 123 29 is_stmt 1 discriminator 1 view .LVU102
 123:../Core/Src/cwt.c ****         for(uint32_t i = 0; i < (N_i + 1); i++)
 383              		.loc 1 123 38 is_stmt 0 discriminator 1 view .LVU103
 384 0164 621C     		adds	r2, r4, #1
 123:../Core/Src/cwt.c ****         for(uint32_t i = 0; i < (N_i + 1); i++)
 385              		.loc 1 123 9 discriminator 1 view .LVU104
 386 0166 9A42     		cmp	r2, r3
 387 0168 D9D8     		bhi	.L11
 388              	.LBE13:
 129:../Core/Src/cwt.c ****         ret = ifft(y_cwt_o, N_i, y_aux);
 389              		.loc 1 129 15 view .LVU105
 390 016a 0297     		str	r7, [sp, #8]
 129:../Core/Src/cwt.c ****         ret = ifft(y_cwt_o, N_i, y_aux);
 391              		.loc 1 129 9 is_stmt 1 view .LVU106
 129:../Core/Src/cwt.c ****         ret = ifft(y_cwt_o, N_i, y_aux);
 392              		.loc 1 129 15 is_stmt 0 view .LVU107
 393 016c 039A     		ldr	r2, [sp, #12]
 394 016e 2146     		mov	r1, r4
 395 0170 2846     		mov	r0, r5
 396              	.LVL46:
 129:../Core/Src/cwt.c ****         ret = ifft(y_cwt_o, N_i, y_aux);
 397              		.loc 1 129 15 view .LVU108
 398 0172 FFF7FEFF 		bl	ifft
 399              	.LVL47:
 131:../Core/Src/cwt.c ****         if(ret)
 400              		.loc 1 131 9 is_stmt 1 view .LVU109
 131:../Core/Src/cwt.c ****         if(ret)
 401              		.loc 1 131 11 is_stmt 0 view .LVU110
 402 0176 0028     		cmp	r0, #0
 403 0178 3ED1     		bne	.L22
 138:../Core/Src/cwt.c ****         period_o[j] = (*fourier_factor) * scale_o[j];
 404              		.loc 1 138 9 is_stmt 1 discriminator 2 view .LVU111
 138:../Core/Src/cwt.c ****         period_o[j] = (*fourier_factor) * scale_o[j];
 405              		.loc 1 138 24 is_stmt 0 discriminator 2 view .LVU112
 406 017a DBED007A 		vldr.32	s15, [fp]
 138:../Core/Src/cwt.c ****         period_o[j] = (*fourier_factor) * scale_o[j];
 407              		.loc 1 138 50 discriminator 2 view .LVU113
 408 017e 99ED007A 		vldr.32	s14, [r9]
 138:../Core/Src/cwt.c ****         period_o[j] = (*fourier_factor) * scale_o[j];
 409              		.loc 1 138 17 discriminator 2 view .LVU114
 410 0182 199B     		ldr	r3, [sp, #100]
 411 0184 5344     		add	r3, r3, r10
 138:../Core/Src/cwt.c ****         period_o[j] = (*fourier_factor) * scale_o[j];
 412              		.loc 1 138 41 discriminator 2 view .LVU115
 413 0186 67EE877A 		vmul.f32	s15, s15, s14
 138:../Core/Src/cwt.c ****         period_o[j] = (*fourier_factor) * scale_o[j];
 414              		.loc 1 138 21 discriminator 2 view .LVU116
 415 018a C3ED007A 		vstr.32	s15, [r3]
 110:../Core/Src/cwt.c ****     for(j = 0; j < (J_i + 1); j++)
 416              		.loc 1 110 31 is_stmt 1 discriminator 2 view .LVU117
 110:../Core/Src/cwt.c ****     for(j = 0; j < (J_i + 1); j++)
ARM GAS  /tmp/ccTelUEZ.s 			page 14


 417              		.loc 1 110 32 is_stmt 0 discriminator 2 view .LVU118
 418 018e 08F10108 		add	r8, r8, #1
 419              	.LVL48:
 420              	.L9:
 110:../Core/Src/cwt.c ****     for(j = 0; j < (J_i + 1); j++)
 421              		.loc 1 110 16 is_stmt 1 discriminator 1 view .LVU119
 110:../Core/Src/cwt.c ****     for(j = 0; j < (J_i + 1); j++)
 422              		.loc 1 110 25 is_stmt 0 discriminator 1 view .LVU120
 423 0192 059B     		ldr	r3, [sp, #20]
 424 0194 0133     		adds	r3, r3, #1
 110:../Core/Src/cwt.c ****     for(j = 0; j < (J_i + 1); j++)
 425              		.loc 1 110 5 discriminator 1 view .LVU121
 426 0196 4345     		cmp	r3, r8
 427 0198 33D9     		bls	.L23
 112:../Core/Src/cwt.c ****         scale_o[j] = s0_i * pow(2, (j * dj_i));
 428              		.loc 1 112 9 is_stmt 1 view .LVU122
 112:../Core/Src/cwt.c ****         scale_o[j] = s0_i * pow(2, (j * dj_i));
 429              		.loc 1 112 39 is_stmt 0 view .LVU123
 430 019a 07EE908A 		vmov	s15, r8	@ int
 431 019e B8EE671A 		vcvt.f32.u32	s2, s15
 432 01a2 21EE081A 		vmul.f32	s2, s2, s16
 112:../Core/Src/cwt.c ****         scale_o[j] = s0_i * pow(2, (j * dj_i));
 433              		.loc 1 112 29 view .LVU124
 434 01a6 B7EEC11A 		vcvt.f64.f32	d1, s2
 435 01aa B0EE000B 		vmov.f64	d0, #2.0e+0
 436 01ae FFF7FEFF 		bl	pow
 437              	.LVL49:
 112:../Core/Src/cwt.c ****         scale_o[j] = s0_i * pow(2, (j * dj_i));
 438              		.loc 1 112 16 view .LVU125
 439 01b2 4FEA880A 		lsl	r10, r8, #2
 440 01b6 1A9B     		ldr	r3, [sp, #104]
 441 01b8 03EB8809 		add	r9, r3, r8, lsl #2
 112:../Core/Src/cwt.c ****         scale_o[j] = s0_i * pow(2, (j * dj_i));
 442              		.loc 1 112 27 view .LVU126
 443 01bc B7EEE87A 		vcvt.f64.f32	d7, s17
 444 01c0 27EE000B 		vmul.f64	d0, d7, d0
 445 01c4 B7EEC00B 		vcvt.f32.f64	s0, d0
 112:../Core/Src/cwt.c ****         scale_o[j] = s0_i * pow(2, (j * dj_i));
 446              		.loc 1 112 20 view .LVU127
 447 01c8 89ED000A 		vstr.32	s0, [r9]
 114:../Core/Src/cwt.c ****         ret = wave_bases[mother_i](wk, N_i, scale_o[j], param_i, 
 448              		.loc 1 114 9 is_stmt 1 view .LVU128
 114:../Core/Src/cwt.c ****         ret = wave_bases[mother_i](wk, N_i, scale_o[j], param_i, 
 449              		.loc 1 114 25 is_stmt 0 view .LVU129
 450 01cc 214B     		ldr	r3, .L25+44
 451 01ce 079A     		ldr	r2, [sp, #28]
 452 01d0 53F82230 		ldr	r3, [r3, r2, lsl #2]
 453 01d4 1F46     		mov	r7, r3
 114:../Core/Src/cwt.c ****         ret = wave_bases[mother_i](wk, N_i, scale_o[j], param_i, 
 454              		.loc 1 114 15 view .LVU130
 455 01d6 049A     		ldr	r2, [sp, #16]
 456 01d8 0192     		str	r2, [sp, #4]
 457 01da 1B9A     		ldr	r2, [sp, #108]
 458 01dc 0092     		str	r2, [sp]
 459 01de 5B46     		mov	r3, fp
 460 01e0 3246     		mov	r2, r6
 461 01e2 F0EE490A 		vmov.f32	s1, s18
ARM GAS  /tmp/ccTelUEZ.s 			page 15


 462 01e6 2146     		mov	r1, r4
 463 01e8 0698     		ldr	r0, [sp, #24]
 464 01ea B847     		blx	r7
 465              	.LVL50:
 117:../Core/Src/cwt.c ****         if(ret)
 466              		.loc 1 117 9 is_stmt 1 view .LVU131
 117:../Core/Src/cwt.c ****         if(ret)
 467              		.loc 1 117 11 is_stmt 0 view .LVU132
 468 01ec 10F0FF0F 		tst	r0, #255
 469 01f0 90D1     		bne	.L24
 470              	.LBB14:
 123:../Core/Src/cwt.c ****         for(uint32_t i = 0; i < (N_i + 1); i++)
 471              		.loc 1 123 22 view .LVU133
 472 01f2 0023     		movs	r3, #0
 473 01f4 029F     		ldr	r7, [sp, #8]
 474 01f6 B5E7     		b	.L10
 475              	.L22:
 123:../Core/Src/cwt.c ****         for(uint32_t i = 0; i < (N_i + 1); i++)
 476              		.loc 1 123 22 view .LVU134
 477              	.LBE14:
 133:../Core/Src/cwt.c ****             UART_puts("It was not possible to compute the inverse fourier \
 478              		.loc 1 133 13 is_stmt 1 view .LVU135
 479 01f8 1748     		ldr	r0, .L25+48
 480              	.LVL51:
 133:../Core/Src/cwt.c ****             UART_puts("It was not possible to compute the inverse fourier \
 481              		.loc 1 133 13 is_stmt 0 view .LVU136
 482 01fa FFF7FEFF 		bl	UART_puts
 483              	.LVL52:
 135:../Core/Src/cwt.c ****             return _EXIT_FAILURE;
 484              		.loc 1 135 13 is_stmt 1 view .LVU137
 135:../Core/Src/cwt.c ****             return _EXIT_FAILURE;
 485              		.loc 1 135 20 is_stmt 0 view .LVU138
 486 01fe 0120     		movs	r0, #1
 487 0200 54E7     		b	.L1
 488              	.L23:
 142:../Core/Src/cwt.c ****     free(y_aux);
 489              		.loc 1 142 5 is_stmt 1 view .LVU139
 490 0202 0398     		ldr	r0, [sp, #12]
 491 0204 FFF7FEFF 		bl	free
 492              	.LVL53:
 144:../Core/Src/cwt.c ****     free(dof_min);
 493              		.loc 1 144 5 view .LVU140
 494 0208 0498     		ldr	r0, [sp, #16]
 495 020a FFF7FEFF 		bl	free
 496              	.LVL54:
 145:../Core/Src/cwt.c ****     free(fourier_factor);
 497              		.loc 1 145 5 view .LVU141
 498 020e 5846     		mov	r0, fp
 499 0210 FFF7FEFF 		bl	free
 500              	.LVL55:
 147:../Core/Src/cwt.c ****     free(wk);
 501              		.loc 1 147 5 view .LVU142
 502 0214 0698     		ldr	r0, [sp, #24]
 503 0216 FFF7FEFF 		bl	free
 504              	.LVL56:
 148:../Core/Src/cwt.c ****     free(daughter);
 505              		.loc 1 148 5 view .LVU143
ARM GAS  /tmp/ccTelUEZ.s 			page 16


 506 021a 3046     		mov	r0, r6
 507 021c FFF7FEFF 		bl	free
 508              	.LVL57:
 150:../Core/Src/cwt.c ****     return _EXIT_SUCCESS;
 509              		.loc 1 150 5 view .LVU144
 150:../Core/Src/cwt.c ****     return _EXIT_SUCCESS;
 510              		.loc 1 150 12 is_stmt 0 view .LVU145
 511 0220 0020     		movs	r0, #0
 512 0222 43E7     		b	.L1
 513              	.L26:
 514 0224 AFF30080 		.align	3
 515              	.L25:
 516 0228 EF39FAFE 		.word	-17155601
 517 022c 422EE63F 		.word	1072049730
 518 0230 182D4454 		.word	1413754136
 519 0234 FB211940 		.word	1075388923
 520 0238 00000000 		.word	.LC0
 521 023c 34000000 		.word	.LC1
 522 0240 68000000 		.word	.LC2
 523 0244 A8000000 		.word	.LC3
 524 0248 D8000000 		.word	.LC4
 525 024c 10010000 		.word	.LC5
 526 0250 00000000 		.word	0
 527 0254 00000000 		.word	wave_bases
 528 0258 44010000 		.word	.LC6
 529              		.cfi_endproc
 530              	.LFE146:
 532              		.text
 533              	.Letext0:
 534              		.file 3 "../Core/Inc/complex.h"
 535              		.file 4 "/usr/lib/gcc/arm-none-eabi/10.3.1/include/stdint.h"
 536              		.file 5 "../Core/Inc/wavelet.h"
 537              		.file 6 "/usr/include/newlib/stdlib.h"
 538              		.file 7 "/usr/include/newlib/math.h"
 539              		.file 8 "../Core/Inc/fft.h"
 540              		.file 9 "../Core/Inc/usart.h"
ARM GAS  /tmp/ccTelUEZ.s 			page 17


DEFINED SYMBOLS
                            *ABS*:0000000000000000 cwt.c
     /tmp/ccTelUEZ.s:17     .rodata.cwt.str1.4:0000000000000000 $d
     /tmp/ccTelUEZ.s:47     .text.cwt:0000000000000000 $t
     /tmp/ccTelUEZ.s:55     .text.cwt:0000000000000000 cwt
     /tmp/ccTelUEZ.s:516    .text.cwt:0000000000000228 $d

UNDEFINED SYMBOLS
malloc
log
calloc
fft
UART_puts
ifft
pow
free
wave_bases
